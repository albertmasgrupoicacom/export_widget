{"version":3,"sources":["replaceShorthandObjectMethod.js"],"names":["t","util","replaceShorthandObjectMethod","path","node","isFunction","Error","isObjectMethod","generator","parameters","params","map","param","cloneDeep","functionExpression","body","async","replaceWithOrRemove","objectProperty","key","computed","get"],"mappings":";;;;AAAA,WAAO,KAAKA,CAAZ,MAAmB,aAAnB;AACA,WAAO,KAAKC,IAAZ,MAAsB,QAAtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAe,SAASC,4BAAT,CAAsCC,IAAtC,EAA4C;AACzD,UAAI,CAACA,KAAKC,IAAN,IAAc,CAACJ,EAAEK,UAAF,CAAaF,KAAKC,IAAlB,CAAnB,EAA4C;AAC1C,cAAM,IAAIE,KAAJ,CAAU,6EAAV,CAAN;AACD;;AAED;AACA;AACA,UAAI,CAACN,EAAEO,cAAF,CAAiBJ,KAAKC,IAAtB,CAAL,EAAkC;AAChC,eAAOD,IAAP;AACD;;AAED;AACA,UAAI,CAACA,KAAKC,IAAL,CAAUI,SAAf,EAA0B;AACxB,eAAOL,IAAP;AACD;;AAED,YAAMM,aAAaN,KAAKC,IAAL,CAAUM,MAAV,CAAiBC,GAAjB,CAAqB,UAAUC,KAAV,EAAiB;AACvD,eAAOZ,EAAEa,SAAF,CAAYD,KAAZ,CAAP;AACD,OAFkB,CAAnB;;AAIA,YAAME,qBAAqBd,EAAEc,kBAAF,CACzB,IADyB,EACnB;AACNL,gBAFyB,EAEb;AACZT,QAAEa,SAAF,CAAYV,KAAKC,IAAL,CAAUW,IAAtB,CAHyB,EAGI;AAC7BZ,WAAKC,IAAL,CAAUI,SAJe,EAKzBL,KAAKC,IAAL,CAAUY,KALe,CAA3B;;AAQAf,WAAKgB,mBAAL,CAAyBd,IAAzB,EACEH,EAAEkB,cAAF,CACElB,EAAEa,SAAF,CAAYV,KAAKC,IAAL,CAAUe,GAAtB,CADF,EAC8B;AAC5BL,wBAFF,EAEsB;AACpBX,WAAKC,IAAL,CAAUgB,QAHZ,EAGsB;AACpB,WAJF,CAIQ;AAJR,OADF;;AASA;AACA;AACA;AACA;AACA,aAAOjB,KAAKkB,GAAL,CAAS,OAAT,CAAP;AACD","file":"replaceShorthandObjectMethod.js","sourcesContent":["import * as t from \"babel-types\";\nimport * as util from \"./util\";\n\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\nexport default function replaceShorthandObjectMethod(path) {\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  }\n\n  // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  }\n\n  // this function only replaces generators.\n  if (!path.node.generator) {\n    return path;\n  }\n\n  const parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  })\n\n  const functionExpression = t.functionExpression(\n    null, // id\n    parameters, // params\n    t.cloneDeep(path.node.body), // body\n    path.node.generator,\n    path.node.async\n  );\n\n  util.replaceWithOrRemove(path,\n    t.objectProperty(\n      t.cloneDeep(path.node.key), // key\n      functionExpression, //value\n      path.node.computed, // computed\n      false // shorthand\n    )\n  );\n\n  // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n  return path.get(\"value\");\n}\n"]}