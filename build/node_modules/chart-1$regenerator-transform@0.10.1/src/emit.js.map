{"version":3,"sources":["emit.js"],"names":["assert","t","leap","meta","util","hasOwn","Object","prototype","hasOwnProperty","Emitter","contextId","ok","assertIdentifier","nextTempId","listing","marked","finalLoc","loc","tryEntries","leapManager","LeapManager","Ep","exports","numericLiteral","mark","assertLiteral","index","length","value","strictEqual","emit","node","isExpression","expressionStatement","assertStatement","push","emitAssign","lhs","rhs","assign","assignmentExpression","contextProperty","name","computed","memberExpression","stringLiteral","identifier","stop","rval","setReturnValue","jump","valuePath","assertExpression","explodeExpression","clearPendingException","tryLoc","assignee","catchCall","callExpression","toLoc","breakStatement","jumpIf","test","ifStatement","blockStatement","jumpIfNot","negatedTest","isUnaryExpression","operator","argument","unaryExpression","makeTempVar","getContextFunction","id","functionExpression","getDispatchLoop","self","cases","current","alreadyEnded","forEach","stmt","i","switchCase","isCompletionStatement","returnStatement","whileStatement","switchStatement","getTryLocsList","lastLocValue","arrayExpression","map","tryEntry","thisLocValue","firstLoc","ce","catchEntry","fe","finallyEntry","locs","afterLoc","explode","path","ignoreResult","assertNode","isDeclaration","getDeclError","isStatement","explodeStatement","type","get","Error","JSON","stringify","labelId","before","after","head","isBlockStatement","containsLeap","withEntry","LabeledEntry","label","LoopEntry","first","update","init","keyIterNextFn","runtimeProperty","keyInfoTmpVar","left","emitAbruptCompletion","target","getBreakLoc","getContinueLoc","disc","defaultLoc","condition","caseLocs","c","assertSwitchCase","conditionalExpression","binaryExpression","discriminant","replaceWithOrRemove","SwitchEntry","casePath","key","elseLoc","alternate","handler","catchLoc","CatchEntry","param","finallyLoc","finalizer","FinallyEntry","TryEntry","getUnmarkedCurrentLoc","updateContextPrevLoc","bodyPath","safeParam","traverse","catchParamVisitor","catchParamName","throwStatement","Identifier","state","isReference","Scope","scope","hasOwnBinding","skip","record","isValidCompletion","notStrictEqual","abruptArgs","call","isLiteral","expr","result","finish","hasLeapingChildren","onlyChildren","explodeViaTempVar","tempVar","childPath","ignoreChildResult","property","calleePath","argsPath","newCallee","newArgs","hasLeapingArgs","argPath","isMemberExpression","newObject","newProperty","unshift","sequenceExpression","newExpression","objectExpression","propPath","isObjectProperty","objectProperty","elemPath","lastIndex","expressions","exprPath","prefix","updateExpression","arg","delegate"],"mappings":"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","file":"emit.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nimport * as t from \"babel-types\";\nimport * as leap from \"./leap\";\nimport * as meta from \"./meta\";\nimport * as util from \"./util\";\n\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  assert.ok(this instanceof Emitter);\n  t.assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\n\nlet Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\nfunction loc() {\n  return t.numericLiteral(-1);\n}\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function(loc) {\n  t.assertLiteral(loc);\n  let index = this.listing.length;\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    assert.strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function(node) {\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function(lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function(lhs, rhs) {\n  return t.expressionStatement(\n    t.assignmentExpression(\"=\", lhs, rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function(name, computed) {\n  return t.memberExpression(\n    this.contextId,\n    computed ? t.stringLiteral(name) : t.identifier(name),\n    !!computed\n  );\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function(rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function(valuePath) {\n  t.assertExpression(valuePath.value);\n\n  this.emitAssign(\n    this.contextProperty(\"rval\"),\n    this.explodeExpression(valuePath)\n  );\n};\n\nEp.clearPendingException = function(tryLoc, assignee) {\n  t.assertLiteral(tryLoc);\n\n  let catchCall = t.callExpression(\n    this.contextProperty(\"catch\", true),\n    [tryLoc]\n  );\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function(toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(t.breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function(test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  this.emit(t.ifStatement(\n    test,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function(test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  let negatedTest;\n  if (t.isUnaryExpression(test) &&\n      test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(\n    negatedTest,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function() {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function(id) {\n  return t.functionExpression(\n    id || null/*Anonymous*/,\n    [this.contextId],\n    t.blockStatement([this.getDispatchLoop()]),\n    false, // Not a generator anymore!\n    false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function() {\n  let self = this;\n  let cases = [];\n  let current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  let alreadyEnded = false;\n\n  self.listing.forEach(function(stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(\n        t.numericLiteral(i),\n        current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt))\n        alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n\n  cases.push(\n    t.switchCase(this.finalLoc, [\n      // Intentionally fall through to the \"end\" case...\n    ]),\n\n    // So that the runtime can jump to the final location without having\n    // to know its offset, we provide the \"end\" case as a synonym.\n    t.switchCase(t.stringLiteral(\"end\"), [\n      // This will check/clear both context.thrown and context.rval.\n      t.returnStatement(\n        t.callExpression(this.contextProperty(\"stop\"), [])\n      )\n    ])\n  );\n\n  return t.whileStatement(\n    t.numericLiteral(1),\n    t.switchStatement(\n      t.assignmentExpression(\n        \"=\",\n        this.contextProperty(\"prev\"),\n        this.contextProperty(\"next\")\n      ),\n      cases\n    )\n  );\n};\n\nEp.getTryLocsList = function() {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  let lastLocValue = 0;\n\n  return t.arrayExpression(\n    this.tryEntries.map(function(tryEntry) {\n      let thisLocValue = tryEntry.firstLoc.value;\n      assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n      lastLocValue = thisLocValue;\n\n      let ce = tryEntry.catchEntry;\n      let fe = tryEntry.finallyEntry;\n\n      let locs = [\n        tryEntry.firstLoc,\n        // The null here makes a hole in the array.\n        ce ? ce.firstLoc : null\n      ];\n\n      if (fe) {\n        locs[2] = fe.firstLoc;\n        locs[3] = fe.afterLoc;\n      }\n\n      return t.arrayExpression(locs);\n    })\n  );\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function(path, ignoreResult) {\n  let node = path.node;\n  let self = this;\n\n  t.assertNode(node);\n\n  if (t.isDeclaration(node))\n    throw getDeclError(node);\n\n  if (t.isStatement(node))\n    return self.explodeStatement(path);\n\n  if (t.isExpression(node))\n    return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n  case \"Program\":\n    return path.get(\"body\").map(\n      self.explodeStatement,\n      self\n    );\n\n  case \"VariableDeclarator\":\n    throw getDeclError(node);\n\n  // These node types should be handled by their parent nodes\n  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n  case \"Property\":\n  case \"SwitchCase\":\n  case \"CatchClause\":\n    throw new Error(\n      node.type + \" nodes should be handled by their parents\");\n\n  default:\n    throw new Error(\n      \"unknown Node of type \" +\n        JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\n    \"all declarations should have been transformed into \" +\n    \"assignments before the Exploder began its work: \" +\n    JSON.stringify(node));\n}\n\nEp.explodeStatement = function(path, labelId) {\n  let stmt = path.node;\n  let self = this;\n  let before, after, head;\n\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n  case \"ExpressionStatement\":\n    self.explodeExpression(path.get(\"expression\"), true);\n    break;\n\n  case \"LabeledStatement\":\n    after = loc();\n\n    // Did you know you can break from any labeled block statement or\n    // control structure? Well, you can! Note: when a labeled loop is\n    // encountered, the leap.LabeledEntry created here will immediately\n    // enclose a leap.LoopEntry on the leap manager's stack, and both\n    // entries will have the same label. Though this works just fine, it\n    // may seem a bit redundant. In theory, we could check here to\n    // determine if stmt knows how to handle its own label; for example,\n    // stmt happens to be a WhileStatement and so we know it's going to\n    // establish its own LoopEntry when we explode it (below). Then this\n    // LabeledEntry would be unnecessary. Alternatively, we might be\n    // tempted not to pass stmt.label down into self.explodeStatement,\n    // because we've handled the label here, but that's a mistake because\n    // labeled loops may contain labeled continue statements, which is not\n    // something we can handle in this generic case. All in all, I think a\n    // little redundancy greatly simplifies the logic of this case, since\n    // it's clear that we handle all possible LabeledStatements correctly\n    // here, regardless of whether they interact with the leap manager\n    // themselves. Also remember that labels and break/continue-to-label\n    // statements are rare, and all of this logic happens at transform\n    // time, so it has no additional runtime cost.\n    self.leapManager.withEntry(\n      new leap.LabeledEntry(after, stmt.label),\n      function() {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      }\n    );\n\n    self.mark(after);\n\n    break;\n\n  case \"WhileStatement\":\n    before = loc();\n    after = loc();\n\n    self.mark(before);\n    self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, before, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n    self.jump(before);\n    self.mark(after);\n\n    break;\n\n  case \"DoWhileStatement\":\n    let first = loc();\n    let test = loc();\n    after = loc();\n\n    self.mark(first);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, test, labelId),\n      function() { self.explode(path.get(\"body\")); }\n    );\n    self.mark(test);\n    self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n    self.mark(after);\n\n    break;\n\n  case \"ForStatement\":\n    head = loc();\n    let update = loc();\n    after = loc();\n\n    if (stmt.init) {\n      // We pass true here to indicate that if stmt.init is an expression\n      // then we do not care about its result.\n      self.explode(path.get(\"init\"), true);\n    }\n\n    self.mark(head);\n\n    if (stmt.test) {\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    } else {\n      // No test means continue unconditionally.\n    }\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, update, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.mark(update);\n\n    if (stmt.update) {\n      // We pass true here to indicate that if stmt.update is an\n      // expression then we do not care about its result.\n      self.explode(path.get(\"update\"), true);\n    }\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"TypeCastExpression\":\n    return self.explodeExpression(path.get(\"expression\"));\n\n  case \"ForInStatement\":\n    head = loc();\n    after = loc();\n\n    let keyIterNextFn = self.makeTempVar();\n    self.emitAssign(\n      keyIterNextFn,\n      t.callExpression(\n        util.runtimeProperty(\"keys\"),\n        [self.explodeExpression(path.get(\"right\"))]\n      )\n    );\n\n    self.mark(head);\n\n    let keyInfoTmpVar = self.makeTempVar();\n    self.jumpIf(\n      t.memberExpression(\n        t.assignmentExpression(\n          \"=\",\n          keyInfoTmpVar,\n          t.callExpression(keyIterNextFn, [])\n        ),\n        t.identifier(\"done\"),\n        false\n      ),\n      after\n    );\n\n    self.emitAssign(\n      stmt.left,\n      t.memberExpression(\n        keyInfoTmpVar,\n        t.identifier(\"value\"),\n        false\n      )\n    );\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, head, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"BreakStatement\":\n    self.emitAbruptCompletion({\n      type: \"break\",\n      target: self.leapManager.getBreakLoc(stmt.label)\n    });\n\n    break;\n\n  case \"ContinueStatement\":\n    self.emitAbruptCompletion({\n      type: \"continue\",\n      target: self.leapManager.getContinueLoc(stmt.label)\n    });\n\n    break;\n\n  case \"SwitchStatement\":\n    // Always save the discriminant into a temporary variable in case the\n    // test expressions overwrite values like context.sent.\n    let disc = self.emitAssign(\n      self.makeTempVar(),\n      self.explodeExpression(path.get(\"discriminant\"))\n    );\n\n    after = loc();\n    let defaultLoc = loc();\n    let condition = defaultLoc;\n    let caseLocs = [];\n\n    // If there are no cases, .cases might be undefined.\n    let cases = stmt.cases || [];\n\n    for (let i = cases.length - 1; i >= 0; --i) {\n      let c = cases[i];\n      t.assertSwitchCase(c);\n\n      if (c.test) {\n        condition = t.conditionalExpression(\n          t.binaryExpression(\"===\", disc, c.test),\n          caseLocs[i] = loc(),\n          condition\n        );\n      } else {\n        caseLocs[i] = defaultLoc;\n      }\n    }\n\n    let discriminant = path.get(\"discriminant\");\n    util.replaceWithOrRemove(discriminant, condition);\n    self.jump(self.explodeExpression(discriminant));\n\n    self.leapManager.withEntry(\n      new leap.SwitchEntry(after),\n      function() {\n        path.get(\"cases\").forEach(function(casePath) {\n          let i = casePath.key;\n          self.mark(caseLocs[i]);\n\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      }\n    );\n\n    self.mark(after);\n    if (defaultLoc.value === -1) {\n      self.mark(defaultLoc);\n      assert.strictEqual(after.value, defaultLoc.value);\n    }\n\n    break;\n\n  case \"IfStatement\":\n    let elseLoc = stmt.alternate && loc();\n    after = loc();\n\n    self.jumpIfNot(\n      self.explodeExpression(path.get(\"test\")),\n      elseLoc || after\n    );\n\n    self.explodeStatement(path.get(\"consequent\"));\n\n    if (elseLoc) {\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeStatement(path.get(\"alternate\"));\n    }\n\n    self.mark(after);\n\n    break;\n\n  case \"ReturnStatement\":\n    self.emitAbruptCompletion({\n      type: \"return\",\n      value: self.explodeExpression(path.get(\"argument\"))\n    });\n\n    break;\n\n  case \"WithStatement\":\n    throw new Error(\"WithStatement not supported in generator functions.\");\n\n  case \"TryStatement\":\n    after = loc();\n\n    let handler = stmt.handler;\n\n    let catchLoc = handler && loc();\n    let catchEntry = catchLoc && new leap.CatchEntry(\n      catchLoc,\n      handler.param\n    );\n\n    let finallyLoc = stmt.finalizer && loc();\n    let finallyEntry = finallyLoc &&\n      new leap.FinallyEntry(finallyLoc, after);\n\n    let tryEntry = new leap.TryEntry(\n      self.getUnmarkedCurrentLoc(),\n      catchEntry,\n      finallyEntry\n    );\n\n    self.tryEntries.push(tryEntry);\n    self.updateContextPrevLoc(tryEntry.firstLoc);\n\n    self.leapManager.withEntry(tryEntry, function() {\n      self.explodeStatement(path.get(\"block\"));\n\n      if (catchLoc) {\n        if (finallyLoc) {\n          // If we have both a catch block and a finally block, then\n          // because we emit the catch block first, we need to jump over\n          // it to the finally block.\n          self.jump(finallyLoc);\n\n        } else {\n          // If there is no finally block, then we need to jump over the\n          // catch block to the fall-through location.\n          self.jump(after);\n        }\n\n        self.updateContextPrevLoc(self.mark(catchLoc));\n\n        let bodyPath = path.get(\"handler.body\");\n        let safeParam = self.makeTempVar();\n        self.clearPendingException(tryEntry.firstLoc, safeParam);\n\n        bodyPath.traverse(catchParamVisitor, {\n          safeParam: safeParam,\n          catchParamName: handler.param.name\n        });\n\n        self.leapManager.withEntry(catchEntry, function() {\n          self.explodeStatement(bodyPath);\n        });\n      }\n\n      if (finallyLoc) {\n        self.updateContextPrevLoc(self.mark(finallyLoc));\n\n        self.leapManager.withEntry(finallyEntry, function() {\n          self.explodeStatement(path.get(\"finalizer\"));\n        });\n\n        self.emit(t.returnStatement(t.callExpression(\n          self.contextProperty(\"finish\"),\n          [finallyEntry.firstLoc]\n        )));\n      }\n    });\n\n    self.mark(after);\n\n    break;\n\n  case \"ThrowStatement\":\n    self.emit(t.throwStatement(\n      self.explodeExpression(path.get(\"argument\"))\n    ));\n\n    break;\n\n  default:\n    throw new Error(\n      \"unknown Statement of type \" +\n        JSON.stringify(stmt.type));\n  }\n};\n\nlet catchParamVisitor = {\n  Identifier: function(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.safeParam);\n    }\n  },\n\n  Scope: function(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function(record) {\n  if (!isValidCompletion(record)) {\n    assert.ok(\n      false,\n      \"invalid completion record: \" +\n        JSON.stringify(record)\n    );\n  }\n\n  assert.notStrictEqual(\n    record.type, \"normal\",\n    \"normal completions are not abrupt\"\n  );\n\n  let abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" ||\n      record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = record.target;\n  } else if (record.type === \"return\" ||\n             record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = record.value;\n    }\n  }\n\n  this.emit(\n    t.returnStatement(\n      t.callExpression(\n        this.contextProperty(\"abrupt\"),\n        abruptArgs\n      )\n    )\n  );\n};\n\nfunction isValidCompletion(record) {\n  let type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" ||\n      type === \"continue\") {\n    return !hasOwn.call(record, \"value\")\n        && t.isLiteral(record.target);\n  }\n\n  if (type === \"return\" ||\n      type === \"throw\") {\n    return hasOwn.call(record, \"value\")\n        && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n}\n\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function() {\n  return t.numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function(loc) {\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      assert.strictEqual(loc.value, this.listing.length);\n    }\n\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function(path, ignoreResult) {\n  let expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  let self = this;\n  let result; // Used optionally by several cases below.\n  let after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  let hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    assert.ok(\n      !ignoreChildResult || !tempVar,\n      \"Ignoring the result of a child expression but forcing it to \" +\n        \"be assigned to a temporary variable?\"\n    );\n\n    let result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {\n      // Side effects already emitted above.\n\n    } else if (tempVar || (hasLeapingChildren &&\n                           !t.isLiteral(result))) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(\n        tempVar || self.makeTempVar(),\n        result\n      );\n    }\n    return result;\n  }\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n  case \"MemberExpression\":\n    return finish(t.memberExpression(\n      self.explodeExpression(path.get(\"object\")),\n      expr.computed\n        ? explodeViaTempVar(null, path.get(\"property\"))\n        : expr.property,\n      expr.computed\n    ));\n\n  case \"CallExpression\":\n    let calleePath = path.get(\"callee\");\n    let argsPath = path.get(\"arguments\");\n\n    let newCallee;\n    let newArgs = [];\n\n    let hasLeapingArgs = false;\n    argsPath.forEach(function(argPath) {\n      hasLeapingArgs = hasLeapingArgs ||\n        meta.containsLeap(argPath.node);\n    });\n\n    if (t.isMemberExpression(calleePath.node)) {\n      if (hasLeapingArgs) {\n        // If the arguments of the CallExpression contained any yield\n        // expressions, then we need to be sure to evaluate the callee\n        // before evaluating the arguments, but if the callee was a member\n        // expression, then we must be careful that the object of the\n        // member expression still gets bound to `this` for the call.\n\n        let newObject = explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(),\n          calleePath.get(\"object\")\n        );\n\n        let newProperty = calleePath.node.computed\n          ? explodeViaTempVar(null, calleePath.get(\"property\"))\n          : calleePath.node.property;\n\n        newArgs.unshift(newObject);\n\n        newCallee = t.memberExpression(\n          t.memberExpression(\n            newObject,\n            newProperty,\n            calleePath.node.computed\n          ),\n          t.identifier(\"call\"),\n          false\n        );\n\n      } else {\n        newCallee = self.explodeExpression(calleePath);\n      }\n\n    } else {\n      newCallee = explodeViaTempVar(null, calleePath);\n\n      if (t.isMemberExpression(newCallee)) {\n        // If the callee was not previously a MemberExpression, then the\n        // CallExpression was \"unqualified,\" meaning its `this` object\n        // should be the global object. If the exploded expression has\n        // become a MemberExpression (e.g. a context property, probably a\n        // temporary variable), then we need to force it to be unqualified\n        // by using the (0, object.property)(...) trick; otherwise, it\n        // will receive the object of the MemberExpression as its `this`\n        // object.\n        newCallee = t.sequenceExpression([\n          t.numericLiteral(0),\n          newCallee\n        ]);\n      }\n    }\n\n    argsPath.forEach(function(argPath) {\n      newArgs.push(explodeViaTempVar(null, argPath));\n    });\n\n    return finish(t.callExpression(\n      newCallee,\n      newArgs\n    ));\n\n  case \"NewExpression\":\n    return finish(t.newExpression(\n      explodeViaTempVar(null, path.get(\"callee\")),\n      path.get(\"arguments\").map(function(argPath) {\n        return explodeViaTempVar(null, argPath);\n      })\n    ));\n\n  case \"ObjectExpression\":\n    return finish(t.objectExpression(\n      path.get(\"properties\").map(function(propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(\n            propPath.node.key,\n            explodeViaTempVar(null, propPath.get(\"value\")),\n            propPath.node.computed\n          );\n        } else {\n          return propPath.node;\n        }\n      })\n    ));\n\n  case \"ArrayExpression\":\n    return finish(t.arrayExpression(\n      path.get(\"elements\").map(function(elemPath) {\n        return explodeViaTempVar(null, elemPath);\n      })\n    ));\n\n  case \"SequenceExpression\":\n    let lastIndex = expr.expressions.length - 1;\n\n    path.get(\"expressions\").forEach(function(exprPath) {\n      if (exprPath.key === lastIndex) {\n        result = self.explodeExpression(exprPath, ignoreResult);\n      } else {\n        self.explodeExpression(exprPath, true);\n      }\n    });\n\n    return result;\n\n  case \"LogicalExpression\":\n    after = loc();\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    let left = explodeViaTempVar(result, path.get(\"left\"));\n\n    if (expr.operator === \"&&\") {\n      self.jumpIfNot(left, after);\n    } else {\n      assert.strictEqual(expr.operator, \"||\");\n      self.jumpIf(left, after);\n    }\n\n    explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"ConditionalExpression\":\n    let elseLoc = loc();\n    after = loc();\n    let test = self.explodeExpression(path.get(\"test\"));\n\n    self.jumpIfNot(test, elseLoc);\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n    self.jump(after);\n\n    self.mark(elseLoc);\n    explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"UnaryExpression\":\n    return finish(t.unaryExpression(\n      expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")),\n      !!expr.prefix\n    ));\n\n  case \"BinaryExpression\":\n    return finish(t.binaryExpression(\n      expr.operator,\n      explodeViaTempVar(null, path.get(\"left\")),\n      explodeViaTempVar(null, path.get(\"right\"))\n    ));\n\n  case \"AssignmentExpression\":\n    return finish(t.assignmentExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"left\")),\n      self.explodeExpression(path.get(\"right\"))\n    ));\n\n  case \"UpdateExpression\":\n    return finish(t.updateExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"argument\")),\n      expr.prefix\n    ));\n\n  case \"YieldExpression\":\n    after = loc();\n    let arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n    if (arg && expr.delegate) {\n      let result = self.makeTempVar();\n\n      self.emit(t.returnStatement(t.callExpression(\n        self.contextProperty(\"delegateYield\"), [\n          arg,\n          t.stringLiteral(result.property.name),\n          after\n        ]\n      )));\n\n      self.mark(after);\n\n      return result;\n    }\n\n    self.emitAssign(self.contextProperty(\"next\"), after);\n    self.emit(t.returnStatement(arg || null));\n    self.mark(after);\n\n    return self.contextProperty(\"sent\");\n\n  default:\n    throw new Error(\n      \"unknown Expression of type \" +\n        JSON.stringify(expr.type));\n  }\n};\n"]}