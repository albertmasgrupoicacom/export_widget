{"version":3,"sources":["visit.js"],"names":["assert","t","hoist","Emitter","replaceShorthandObjectMethod","util","exports","visitor","Function","exit","path","state","node","generator","async","opts","asyncGenerators","generators","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","get","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","body","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","didRenameArguments","renameArguments","variableDeclaration","argumentIdentifier","_shadowedFunctionLiteral","declarations","variableDeclarator","emitter","explode","wrapArgs","getContextFunction","nullLiteral","thisExpression","tryLocsList","getTryLocsList","wrapCall","callExpression","runtimeProperty","returnStatement","blockStatement","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","requeue","funPath","assertFunction","parent","isFunctionDeclaration","getMarkedFunctionId","getMarkInfo","require","makeAccessor","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","funcPath","argumentsVisitor","skip","Identifier","isReference","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"mappings":"AAAA;;;;;;;;;;AAUA;;;;;;AAEA,WAAOA,MAAP,MAAmB,QAAnB;AACA,WAAO,KAAKC,CAAZ,MAAmB,aAAnB;AACA,aAASC,KAAT,QAAsB,SAAtB;AACA,aAASC,OAAT,QAAwB,QAAxB;AACA,WAAOC,4BAAP,MAAyC,gCAAzC;AACA,WAAO,KAAKC,IAAZ,MAAsB,QAAtB;;AAEAC,YAAQC,OAAR,GAAkB;AAChBC,gBAAU;AACRC,cAAM,UAASC,IAAT,EAAeC,KAAf,EAAsB;AAC1B,cAAIC,OAAOF,KAAKE,IAAhB;;AAEA,cAAIA,KAAKC,SAAT,EAAoB;AAClB,gBAAID,KAAKE,KAAT,EAAgB;AACd;AACA,kBAAIH,MAAMI,IAAN,CAAWC,eAAX,KAA+B,KAAnC,EAA0C;AAC3C,aAHD,MAGO;AACL;AACA,kBAAIL,MAAMI,IAAN,CAAWE,UAAX,KAA0B,KAA9B,EAAqC;AACtC;AACF,WARD,MAQO,IAAIL,KAAKE,KAAT,EAAgB;AACrB;AACA,gBAAIH,MAAMI,IAAN,CAAWD,KAAX,KAAqB,KAAzB,EAAgC;AACjC,WAHM,MAGA;AACL;AACA;AACD;;AAED;AACAJ,iBAAON,6BAA6BM,IAA7B,CAAP;AACAE,iBAAOF,KAAKE,IAAZ;;AAEA,cAAIM,YAAYR,KAAKS,KAAL,CAAWC,qBAAX,CAAiC,SAAjC,CAAhB;AACA,cAAIC,SAASX,KAAKS,KAAL,CAAWC,qBAAX,CAAiC,MAAjC,CAAb;;AAEAV,eAAKY,WAAL;AACA,cAAIC,gBAAgBb,KAAKc,GAAL,CAAS,MAAT,CAApB;;AAEA,cAAIZ,KAAKE,KAAT,EAAgB;AACdS,0BAAcE,QAAd,CAAuBC,YAAvB;AACD;;AAEDH,wBAAcE,QAAd,CAAuBE,mBAAvB,EAA4C;AAC1CC,qBAASV;AADiC,WAA5C;;AAIA,cAAIW,YAAY,EAAhB;AACA,cAAIC,YAAY,EAAhB;;AAEAP,wBAAcC,GAAd,CAAkB,MAAlB,EAA0BO,OAA1B,CAAkC,UAASC,SAAT,EAAoB;AACpD,gBAAIpB,OAAOoB,UAAUpB,IAArB;AACA,gBAAIX,EAAEgC,qBAAF,CAAwBrB,IAAxB,KACAX,EAAEiC,eAAF,CAAkBtB,KAAKuB,UAAvB,CADJ,EACwC;AACtC;AACA;AACA;AACA;AACA;AACAN,wBAAUO,IAAV,CAAexB,IAAf;AACD,aARD,MAQO,IAAIA,QAAQA,KAAKyB,WAAL,IAAoB,IAAhC,EAAsC;AAC3CR,wBAAUO,IAAV,CAAexB,IAAf;AACD,aAFM,MAEA;AACLkB,wBAAUM,IAAV,CAAexB,IAAf;AACD;AACF,WAfD;;AAiBA,cAAIiB,UAAUS,MAAV,GAAmB,CAAvB,EAA0B;AACxB;AACA;AACAf,0BAAcX,IAAd,CAAmB2B,IAAnB,GAA0BT,SAA1B;AACD;;AAED,cAAIU,cAAcC,eAAe/B,IAAf,CAAlB;AACA;AACA;AACA;AACAT,YAAEyC,gBAAF,CAAmB9B,KAAK+B,EAAxB;AACA,cAAIC,YAAY3C,EAAE4C,UAAF,CAAajC,KAAK+B,EAAL,CAAQG,IAAR,GAAe,GAA5B,CAAhB;;AAEA;AACA;AACA,cAAIC,OAAO7C,MAAMQ,IAAN,CAAX;;AAEA,cAAIsC,qBAAqBC,gBAAgBvC,IAAhB,EAAsBW,MAAtB,CAAzB;AACA,cAAI2B,kBAAJ,EAAwB;AACtBD,mBAAOA,QAAQ9C,EAAEiD,mBAAF,CAAsB,KAAtB,EAA6B,EAA7B,CAAf;AACA,kBAAMC,qBAAqBlD,EAAE4C,UAAF,CAAa,WAAb,CAA3B;AACA;AACAM,+BAAmBC,wBAAnB,GAA8C1C,IAA9C;AACAqC,iBAAKM,YAAL,CAAkBjB,IAAlB,CAAuBnC,EAAEqD,kBAAF,CACrBjC,MADqB,EACb8B,kBADa,CAAvB;AAGD;;AAED,cAAII,UAAU,IAAIpD,OAAJ,CAAYe,SAAZ,CAAd;AACAqC,kBAAQC,OAAR,CAAgB9C,KAAKc,GAAL,CAAS,MAAT,CAAhB;;AAEA,cAAIuB,QAAQA,KAAKM,YAAL,CAAkBf,MAAlB,GAA2B,CAAvC,EAA0C;AACxCT,sBAAUO,IAAV,CAAeW,IAAf;AACD;;AAED,cAAIU,WAAW,CACbF,QAAQG,kBAAR,CAA2Bd,SAA3B,CADa;AAEb;AACA;AACA;AACAhC,eAAKC,SAAL,GAAiB2B,WAAjB,GAA+BvC,EAAE0D,WAAF,EALlB,EAMb1D,EAAE2D,cAAF,EANa,CAAf;;AASA,cAAIC,cAAcN,QAAQO,cAAR,EAAlB;AACA,cAAID,WAAJ,EAAiB;AACfJ,qBAASrB,IAAT,CAAcyB,WAAd;AACD;;AAED,cAAIE,WAAW9D,EAAE+D,cAAF,CACb3D,KAAK4D,eAAL,CAAqBrD,KAAKE,KAAL,GAAa,OAAb,GAAuB,MAA5C,CADa,EAEb2C,QAFa,CAAf;;AAKA5B,oBAAUO,IAAV,CAAenC,EAAEiE,eAAF,CAAkBH,QAAlB,CAAf;AACAnD,eAAK2B,IAAL,GAAYtC,EAAEkE,cAAF,CAAiBtC,SAAjB,CAAZ;;AAEA,gBAAMuC,gBAAgB7C,cAAcX,IAAd,CAAmByD,UAAzC;AACA,cAAID,aAAJ,EAAmB;AACjB;AACA;AACAxD,iBAAK2B,IAAL,CAAU8B,UAAV,GAAuBD,aAAvB;AACD;;AAED,cAAIE,uBAAuB1D,KAAKC,SAAhC;AACA,cAAIyD,oBAAJ,EAA0B;AACxB1D,iBAAKC,SAAL,GAAiB,KAAjB;AACD;;AAED,cAAID,KAAKE,KAAT,EAAgB;AACdF,iBAAKE,KAAL,GAAa,KAAb;AACD;;AAED,cAAIwD,wBAAwBrE,EAAEsE,YAAF,CAAe3D,IAAf,CAA5B,EAAkD;AAChDP,iBAAKmE,mBAAL,CAAyB9D,IAAzB,EAA+BT,EAAE+D,cAAF,CAAiB3D,KAAK4D,eAAL,CAAqB,MAArB,CAAjB,EAA+C,CAACrD,IAAD,CAA/C,CAA/B;AACAF,iBAAK+D,UAAL,CAAgB,SAAhB,EAA2B,WAA3B;AACD;;AAED;AACA;AACA;AACA/D,eAAKgE,OAAL;AACD;AA5IO;AADM,KAAlB;;AAiJA;AACA;AACA;AACA;AACA,aAASjC,cAAT,CAAwBkC,OAAxB,EAAiC;AAC/B,UAAI/D,OAAO+D,QAAQ/D,IAAnB;AACAX,QAAE2E,cAAF,CAAiBhE,IAAjB;;AAEA,UAAI,CAACA,KAAK+B,EAAV,EAAc;AACZ;AACA;AACA/B,aAAK+B,EAAL,GAAUgC,QAAQxD,KAAR,CAAc0D,MAAd,CAAqBzD,qBAArB,CAA2C,QAA3C,CAAV;AACD;;AAED,UAAIR,KAAKC,SAAL,IAAkB;AAClBZ,QAAE6E,qBAAF,CAAwBlE,IAAxB,CADJ,EACmC;AACjC;AACA,eAAOmE,oBAAoBJ,OAApB,CAAP;AACD;;AAED,aAAO/D,KAAK+B,EAAZ;AACD;;AAED,UAAMqC,cAAcC,QAAQ,iBAAR,EAAmBC,YAAnB,EAApB;;AAEA,aAASH,mBAAT,CAA6BJ,OAA7B,EAAsC;AACpC,YAAM/D,OAAO+D,QAAQ/D,IAArB;AACAX,QAAEyC,gBAAF,CAAmB9B,KAAK+B,EAAxB;;AAEA,YAAMwC,YAAYR,QAAQS,UAAR,CAAmB,UAAU1E,IAAV,EAAgB;AACnD,eAAOA,KAAK2E,SAAL,MAAoB3E,KAAK4E,gBAAL,EAA3B;AACD,OAFiB,CAAlB;;AAIA,UAAI,CAACH,SAAL,EAAgB;AACd,eAAOvE,KAAK+B,EAAZ;AACD;;AAED,YAAM4C,QAAQJ,UAAUvE,IAAxB;AACAZ,aAAOwF,EAAP,CAAUC,MAAMC,OAAN,CAAcH,MAAMhD,IAApB,CAAV;;AAEA,YAAMoD,OAAOX,YAAYO,KAAZ,CAAb;AACA,UAAI,CAACI,KAAKC,IAAV,EAAgB;AACdD,aAAKC,IAAL,GAAY3F,EAAEiD,mBAAF,CAAsB,KAAtB,EAA6B,EAA7B,CAAZ;AACAiC,kBAAUU,gBAAV,CAA2B,MAA3B,EAAmCF,KAAKC,IAAxC;AACAD,aAAKG,QAAL,GAAgBX,UAAU3D,GAAV,CAAc,QAAd,CAAhB;AACD;;AAEDxB,aAAO+F,WAAP,CAAmBJ,KAAKG,QAAL,CAAclF,IAAjC,EAAuC+E,KAAKC,IAA5C;;AAEA;AACA,YAAMI,WAAWb,UAAUhE,KAAV,CAAgBC,qBAAhB,CAAsC,QAAtC,CAAjB;AACA,YAAM6E,cAAchG,EAAE+D,cAAF,CAClB3D,KAAK4D,eAAL,CAAqB,MAArB,CADkB,EAElB,CAACrD,KAAK+B,EAAN,CAFkB,CAApB;;AAKA,YAAMuD,QAAQP,KAAKC,IAAL,CAAUvC,YAAV,CAAuBjB,IAAvB,CACZnC,EAAEqD,kBAAF,CAAqB0C,QAArB,EAA+BC,WAA/B,CADY,IAEV,CAFJ;;AAIA,YAAME,kBACJR,KAAKG,QAAL,CAActE,GAAd,CAAkB,kBAAkB0E,KAAlB,GAA0B,OAA5C,CADF;;AAGAlG,aAAO+F,WAAP,CAAmBI,gBAAgBvF,IAAnC,EAAyCqF,WAAzC;;AAEAE,sBAAgB1B,UAAhB,CAA2B,SAA3B,EAAsC,WAAtC;;AAEA,aAAOuB,QAAP;AACD;;AAED,aAAS/C,eAAT,CAAyBmD,QAAzB,EAAmC/E,MAAnC,EAA2C;AACzC,UAAIV,QAAQ;AACVqC,4BAAoB,KADV;AAEV3B,gBAAQA;AAFE,OAAZ;;AAKA+E,eAAS3E,QAAT,CAAkB4E,gBAAlB,EAAoC1F,KAApC;;AAEA;AACA;AACA;AACA;AACA,aAAOA,MAAMqC,kBAAb;AACD;;AAED,QAAIqD,mBAAmB;AACrB,gDAA0C,UAAS3F,IAAT,EAAe;AACvDA,aAAK4F,IAAL;AACD,OAHoB;;AAKrBC,kBAAY,UAAS7F,IAAT,EAAeC,KAAf,EAAsB;AAChC,YAAID,KAAKE,IAAL,CAAUkC,IAAV,KAAmB,WAAnB,IAAkCzC,KAAKmG,WAAL,CAAiB9F,IAAjB,CAAtC,EAA8D;AAC5DL,eAAKmE,mBAAL,CAAyB9D,IAAzB,EAA+BC,MAAMU,MAArC;AACAV,gBAAMqC,kBAAN,GAA2B,IAA3B;AACD;AACF;AAVoB,KAAvB;;AAaA,QAAIrB,sBAAsB;AACxB8E,mBAAa/F,IAAb,EAAmB;AACjB,YAAI,EAAEE,IAAF,KAAWF,IAAf;;AAEA,YAAIE,KAAK8F,IAAL,CAAU5D,IAAV,KAAmB,UAAnB,IAAiClC,KAAK+F,QAAL,CAAc7D,IAAd,KAAuB,MAA5D,EAAoE;AAClEzC,eAAKmE,mBAAL,CAAyB9D,IAAzB,EAA+BT,EAAE2G,gBAAF,CAAmB,KAAKhF,OAAxB,EAAiC3B,EAAE4C,UAAF,CAAa,OAAb,CAAjC,CAA/B;AACD;AACF;AAPuB,KAA1B;;AAUA,QAAInB,eAAe;AACjBlB,gBAAU,UAASE,IAAT,EAAe;AACvBA,aAAK4F,IAAL,GADuB,CACV;AACd,OAHgB;;AAKjBO,uBAAiB,UAASnG,IAAT,EAAe;AAC9B;AACA,YAAIoG,WAAWpG,KAAKE,IAAL,CAAUkG,QAAzB;;AAEA;AACA;AACA;AACAzG,aAAKmE,mBAAL,CAAyB9D,IAAzB,EAA+BT,EAAE8G,eAAF,CAC7B9G,EAAE+D,cAAF,CACE3D,KAAK4D,eAAL,CAAqB,OAArB,CADF,EAEE,CAAC6C,QAAD,CAFF,CAD6B,EAK7B,KAL6B,CAA/B;AAOD;AAnBgB,KAAnB","file":"visit.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n\"use strict\";\n\nimport assert from \"assert\";\nimport * as t from \"babel-types\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport replaceShorthandObjectMethod from \"./replaceShorthandObjectMethod\";\nimport * as util from \"./util\";\n\nexports.visitor = {\n  Function: {\n    exit: function(path, state) {\n      let node = path.node;\n\n      if (node.generator) {\n        if (node.async) {\n          // Async generator\n          if (state.opts.asyncGenerators === false) return;\n        } else {\n          // Plain generator\n          if (state.opts.generators === false) return;\n        }\n      } else if (node.async) {\n        // Async function\n        if (state.opts.async === false) return;\n      } else {\n        // Not a generator or async function.\n        return;\n      }\n\n      // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n      path = replaceShorthandObjectMethod(path);\n      node = path.node;\n\n      let contextId = path.scope.generateUidIdentifier(\"context\");\n      let argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      let bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      let outerBody = [];\n      let innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function(childPath) {\n        let node = childPath.node;\n        if (t.isExpressionStatement(node) &&\n            t.isStringLiteral(node.expression)) {\n          // Babylon represents directives like \"use strict\" as elements\n          // of a bodyBlockPath.node.directives array, but they could just\n          // as easily be represented (by other parsers) as traditional\n          // string-literal-valued expression statements, so we need to\n          // handle that here. (#248)\n          outerBody.push(node);\n        } else if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      let outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      let innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      let vars = hoist(path);\n\n      let didRenameArguments = renameArguments(path, argsId);\n      if (didRenameArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        const argumentIdentifier = t.identifier(\"arguments\");\n        // we need to do this as otherwise arguments in arrow functions gets hoisted\n        argumentIdentifier._shadowedFunctionLiteral = path;\n        vars.declarations.push(t.variableDeclarator(\n          argsId, argumentIdentifier\n        ));\n      }\n\n      let emitter = new Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      let wrapArgs = [\n        emitter.getContextFunction(innerFnId),\n        // Async functions that are not generators don't care about the\n        // outer function because they don't need it to be marked and don't\n        // inherit from its .prototype.\n        node.generator ? outerFnExpr : t.nullLiteral(),\n        t.thisExpression()\n      ];\n\n      let tryLocsList = emitter.getTryLocsList();\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      }\n\n      let wrapCall = t.callExpression(\n        util.runtimeProperty(node.async ? \"async\" : \"wrap\"),\n        wrapArgs\n      );\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n\n      const oldDirectives = bodyBlockPath.node.directives;\n      if (oldDirectives) {\n        // Babylon represents directives like \"use strict\" as elements of\n        // a bodyBlockPath.node.directives array. (#248)\n        node.body.directives = oldDirectives;\n      }\n\n      let wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]))\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    }\n  }\n};\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n      t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return node.id;\n}\n\nconst getMarkInfo = require(\"private\").makeAccessor();\n\nfunction getMarkedFunctionId(funPath) {\n  const node = funPath.node;\n  t.assertIdentifier(node.id);\n\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  const block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n\n  const info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  assert.strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = t.callExpression(\n    util.runtimeProperty(\"mark\"),\n    [node.id]\n  );\n\n  const index = info.decl.declarations.push(\n    t.variableDeclarator(markedId, markCallExp)\n  ) - 1;\n\n  const markCallExpPath =\n    info.declPath.get(\"declarations.\" + index + \".init\");\n\n  assert.strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n\n  return markedId;\n}\n\nfunction renameArguments(funcPath, argsId) {\n  let state = {\n    didRenameArguments: false,\n    argsId: argsId\n  };\n\n  funcPath.traverse(argumentsVisitor, state);\n\n  // If the traversal replaced any arguments references, then we need to\n  // alias the outer function's arguments binding (be it the implicit\n  // arguments object or some other parameter or variable) to the variable\n  // named by argsId.\n  return state.didRenameArguments;\n}\n\nlet argumentsVisitor = {\n  \"FunctionExpression|FunctionDeclaration\": function(path) {\n    path.skip();\n  },\n\n  Identifier: function(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.argsId);\n      state.didRenameArguments = true;\n    }\n  }\n};\n\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let { node } = path;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      util.replaceWithOrRemove(path, t.memberExpression(this.context, t.identifier(\"_sent\")));\n    }\n  }\n};\n\nlet awaitVisitor = {\n  Function: function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function(path) {\n    // Convert await expressions to yield expressions.\n    let argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(\n      t.callExpression(\n        util.runtimeProperty(\"awrap\"),\n        [argument]\n      ),\n      false\n    ));\n  }\n};\n"]}