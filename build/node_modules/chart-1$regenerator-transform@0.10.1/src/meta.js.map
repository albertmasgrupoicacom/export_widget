{"version":3,"sources":["meta.js"],"names":["assert","m","require","makeAccessor","t","hasOwn","Object","prototype","hasOwnProperty","makePredicate","propertyName","knownTypes","onlyChildren","node","assertNode","result","check","child","Array","isArray","some","isNode","strictEqual","predicate","keys","VISITOR_KEYS","type","i","length","key","meta","call","opaqueTypes","FunctionExpression","ArrowFunctionExpression","sideEffectTypes","CallExpression","ForInStatement","UnaryExpression","BinaryExpression","AssignmentExpression","UpdateExpression","NewExpression","leapTypes","YieldExpression","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","exports","hasSideEffects","containsLeap"],"mappings":";;;;AAAA;;;;;;;;;;AAUA,WAAOA,MAAP,MAAmB,QAAnB;AACA,QAAIC,IAAIC,QAAQ,iBAAR,EAAmBC,YAAnB,EAAR;AACA,WAAO,KAAKC,CAAZ,MAAmB,aAAnB;AACA,QAAIC,SAASC,OAAOC,SAAP,CAAiBC,cAA9B;;AAEA,aAASC,aAAT,CAAuBC,YAAvB,EAAqCC,UAArC,EAAiD;AAC/C,eAASC,YAAT,CAAsBC,IAAtB,EAA4B;AAC1BT,UAAEU,UAAF,CAAaD,IAAb;;AAEA;AACA,YAAIE,SAAS,KAAb;;AAEA,iBAASC,KAAT,CAAeC,KAAf,EAAsB;AACpB,cAAIF,MAAJ,EAAY;AACV;AACD,WAFD,MAEO,IAAIG,MAAMC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AAC/BA,kBAAMG,IAAN,CAAWJ,KAAX;AACD,WAFM,MAEA,IAAIZ,EAAEiB,MAAF,CAASJ,KAAT,CAAJ,EAAqB;AAC1BjB,mBAAOsB,WAAP,CAAmBP,MAAnB,EAA2B,KAA3B;AACAA,qBAASQ,UAAUN,KAAV,CAAT;AACD;AACD,iBAAOF,MAAP;AACD;;AAED,YAAIS,OAAOpB,EAAEqB,YAAF,CAAeZ,KAAKa,IAApB,CAAX;AACA,YAAIF,IAAJ,EAAU;AACR,eAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAIH,KAAKI,MAAzB,EAAiCD,GAAjC,EAAsC;AACpC,gBAAIE,MAAML,KAAKG,CAAL,CAAV;AACA,gBAAIV,QAAQJ,KAAKgB,GAAL,CAAZ;AACAb,kBAAMC,KAAN;AACD;AACF;;AAED,eAAOF,MAAP;AACD;;AAED,eAASQ,SAAT,CAAmBV,IAAnB,EAAyB;AACvBT,UAAEU,UAAF,CAAaD,IAAb;;AAEA,YAAIiB,OAAO7B,EAAEY,IAAF,CAAX;AACA,YAAIR,OAAO0B,IAAP,CAAYD,IAAZ,EAAkBpB,YAAlB,CAAJ,EACE,OAAOoB,KAAKpB,YAAL,CAAP;;AAEF;AACA;AACA,YAAIL,OAAO0B,IAAP,CAAYC,WAAZ,EAAyBnB,KAAKa,IAA9B,CAAJ,EACE,OAAOI,KAAKpB,YAAL,IAAqB,KAA5B;;AAEF,YAAIL,OAAO0B,IAAP,CAAYpB,UAAZ,EAAwBE,KAAKa,IAA7B,CAAJ,EACE,OAAOI,KAAKpB,YAAL,IAAqB,IAA5B;;AAEF,eAAOoB,KAAKpB,YAAL,IAAqBE,aAAaC,IAAb,CAA5B;AACD;;AAEDU,gBAAUX,YAAV,GAAyBA,YAAzB;;AAEA,aAAOW,SAAP;AACD;;AAED,QAAIS,cAAc;AAChBC,0BAAoB,IADJ;AAEhBC,+BAAyB;AAFT,KAAlB;;AAKA;AACA;AACA,QAAIC,kBAAkB;AACpBC,sBAAgB,IADI,EACE;AACtBC,sBAAgB,IAFI,EAEE;AACtBC,uBAAiB,IAHG,EAGG;AACvBC,wBAAkB,IAJE,EAII;AACxBC,4BAAsB,IALF,EAKQ;AAC5BC,wBAAkB,IANE,EAMI;AACxBC,qBAAe,IAPK,CAOA;AAPA,KAAtB;;AAUA;AACA,QAAIC,YAAY;AACdC,uBAAiB,IADH;AAEdC,sBAAgB,IAFF;AAGdC,yBAAmB,IAHL;AAIdC,uBAAiB,IAJH;AAKdC,sBAAgB;AALF,KAAhB;;AAQA;AACA,SAAK,IAAItB,IAAT,IAAiBiB,SAAjB,EAA4B;AAC1B,UAAItC,OAAO0B,IAAP,CAAYY,SAAZ,EAAuBjB,IAAvB,CAAJ,EAAkC;AAChCS,wBAAgBT,IAAhB,IAAwBiB,UAAUjB,IAAV,CAAxB;AACD;AACF;;AAEDuB,YAAQC,cAAR,GAAyBzC,cAAc,gBAAd,EAAgC0B,eAAhC,CAAzB;AACAc,YAAQE,YAAR,GAAuB1C,cAAc,cAAd,EAA8BkC,SAA9B,CAAvB","file":"meta.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nlet m = require(\"private\").makeAccessor();\nimport * as t from \"babel-types\";\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    let result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n\n    let keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    let meta = m(node);\n    if (hasOwn.call(meta, propertyName))\n      return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type))\n      return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type))\n      return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nlet opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nlet sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nlet leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (let type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);\n"]}