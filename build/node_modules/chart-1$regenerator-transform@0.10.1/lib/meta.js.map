{"version":3,"sources":["meta.js"],"names":["_assert","require","_assert2","_interopRequireDefault","_babelTypes","t","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","default","m","makeAccessor","hasOwn","makePredicate","propertyName","knownTypes","onlyChildren","node","assertNode","result","check","child","Array","isArray","some","isNode","strictEqual","predicate","keys","VISITOR_KEYS","type","i","length","meta","opaqueTypes","FunctionExpression","ArrowFunctionExpression","sideEffectTypes","CallExpression","ForInStatement","UnaryExpression","BinaryExpression","AssignmentExpression","UpdateExpression","NewExpression","leapTypes","YieldExpression","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","exports","hasSideEffects","containsLeap"],"mappings":"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","file":"meta.js","sourcesContent":["\"use strict\";\n\nvar _assert = require(\"assert\");\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar m = require(\"private\").makeAccessor(); /**\n                                            * Copyright (c) 2014, Facebook, Inc.\n                                            * All rights reserved.\n                                            *\n                                            * This source code is licensed under the BSD-style license found in the\n                                            * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n                                            * additional grant of patent rights can be found in the PATENTS file in\n                                            * the same directory.\n                                            */\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    var result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        _assert2.default.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n\n    var keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nvar opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nvar sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);"]}