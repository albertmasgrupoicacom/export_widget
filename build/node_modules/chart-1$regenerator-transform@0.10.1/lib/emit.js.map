{"version":3,"sources":["emit.js"],"names":["_stringify","require","_stringify2","_interopRequireDefault","_assert","_assert2","_babelTypes","t","_interopRequireWildcard","_leap","leap","_meta","meta","_util","util","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","default","hasOwn","Emitter","contextId","ok","assertIdentifier","nextTempId","listing","marked","finalLoc","loc","tryEntries","leapManager","LeapManager","Ep","exports","numericLiteral","mark","assertLiteral","index","length","value","strictEqual","emit","node","isExpression","expressionStatement","assertStatement","push","emitAssign","lhs","rhs","assign","assignmentExpression","contextProperty","name","computed","memberExpression","stringLiteral","identifier","stop","rval","setReturnValue","jump","valuePath","assertExpression","explodeExpression","clearPendingException","tryLoc","assignee","catchCall","callExpression","toLoc","breakStatement","jumpIf","test","ifStatement","blockStatement","jumpIfNot","negatedTest","isUnaryExpression","operator","argument","unaryExpression","makeTempVar","getContextFunction","id","functionExpression","getDispatchLoop","self","cases","current","alreadyEnded","forEach","stmt","i","switchCase","isCompletionStatement","returnStatement","whileStatement","switchStatement","getTryLocsList","lastLocValue","arrayExpression","map","tryEntry","thisLocValue","firstLoc","ce","catchEntry","fe","finallyEntry","locs","afterLoc","explode","path","ignoreResult","assertNode","isDeclaration","getDeclError","isStatement","explodeStatement","type","get","Error","labelId","before","after","head","isBlockStatement","containsLeap","withEntry","LabeledEntry","label","LoopEntry","first","update","init","keyIterNextFn","runtimeProperty","keyInfoTmpVar","left","emitAbruptCompletion","target","getBreakLoc","getContinueLoc","disc","defaultLoc","condition","caseLocs","c","assertSwitchCase","conditionalExpression","binaryExpression","discriminant","replaceWithOrRemove","SwitchEntry","casePath","elseLoc","alternate","handler","catchLoc","CatchEntry","param","finallyLoc","finalizer","FinallyEntry","TryEntry","getUnmarkedCurrentLoc","updateContextPrevLoc","bodyPath","safeParam","traverse","catchParamVisitor","catchParamName","throwStatement","Identifier","state","isReference","Scope","scope","hasOwnBinding","skip","record","isValidCompletion","notStrictEqual","abruptArgs","isLiteral","expr","result","finish","hasLeapingChildren","onlyChildren","explodeViaTempVar","tempVar","childPath","ignoreChildResult","property","calleePath","argsPath","newCallee","newArgs","hasLeapingArgs","argPath","isMemberExpression","newObject","newProperty","unshift","sequenceExpression","newExpression","objectExpression","propPath","isObjectProperty","objectProperty","elemPath","lastIndex","expressions","exprPath","prefix","updateExpression","arg","delegate","_result"],"mappings":"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","file":"emit.js","sourcesContent":["\"use strict\";\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _assert = require(\"assert\");\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _leap = require(\"./leap\");\n\nvar leap = _interopRequireWildcard(_leap);\n\nvar _meta = require(\"./meta\");\n\nvar meta = _interopRequireWildcard(_meta);\n\nvar _util = require(\"./util\");\n\nvar util = _interopRequireWildcard(_util);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hasOwn = Object.prototype.hasOwnProperty; /**\n                                               * Copyright (c) 2014, Facebook, Inc.\n                                               * All rights reserved.\n                                               *\n                                               * This source code is licensed under the BSD-style license found in the\n                                               * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n                                               * additional grant of patent rights can be found in the PATENTS file in\n                                               * the same directory.\n                                               */\n\nfunction Emitter(contextId) {\n  _assert2.default.ok(this instanceof Emitter);\n  t.assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\n\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\nfunction loc() {\n  return t.numericLiteral(-1);\n}\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function (loc) {\n  t.assertLiteral(loc);\n  var index = this.listing.length;\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    _assert2.default.strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function (node) {\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function (lhs, rhs) {\n  return t.expressionStatement(t.assignmentExpression(\"=\", lhs, rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function (name, computed) {\n  return t.memberExpression(this.contextId, computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function (valuePath) {\n  t.assertExpression(valuePath.value);\n\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\n\nEp.clearPendingException = function (tryLoc, assignee) {\n  t.assertLiteral(tryLoc);\n\n  var catchCall = t.callExpression(this.contextProperty(\"catch\", true), [tryLoc]);\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(t.breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function (test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function (test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  var negatedTest = void 0;\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function (id) {\n  return t.functionExpression(id || null /*Anonymous*/\n  , [this.contextId], t.blockStatement([this.getDispatchLoop()]), false, // Not a generator anymore!\n  false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function () {\n  var self = this;\n  var cases = [];\n  var current = void 0;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  var alreadyEnded = false;\n\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n\n  cases.push(t.switchCase(this.finalLoc, [\n    // Intentionally fall through to the \"end\" case...\n  ]),\n\n  // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [\n  // This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\n\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  var lastLocValue = 0;\n\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    var thisLocValue = tryEntry.firstLoc.value;\n    _assert2.default.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n    lastLocValue = thisLocValue;\n\n    var ce = tryEntry.catchEntry;\n    var fe = tryEntry.finallyEntry;\n\n    var locs = [tryEntry.firstLoc,\n    // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n\n    return t.arrayExpression(locs);\n  }));\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function (path, ignoreResult) {\n  var node = path.node;\n  var self = this;\n\n  t.assertNode(node);\n\n  if (t.isDeclaration(node)) throw getDeclError(node);\n\n  if (t.isStatement(node)) return self.explodeStatement(path);\n\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n\n    default:\n      throw new Error(\"unknown Node of type \" + (0, _stringify2.default)(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + (0, _stringify2.default)(node));\n}\n\nEp.explodeStatement = function (path, labelId) {\n  var stmt = path.node;\n  var self = this;\n  var before = void 0,\n      after = void 0,\n      head = void 0;\n\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n\n    case \"LabeledStatement\":\n      after = loc();\n\n      // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n\n      self.mark(after);\n\n      break;\n\n    case \"WhileStatement\":\n      before = loc();\n      after = loc();\n\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n\n      break;\n\n    case \"DoWhileStatement\":\n      var first = loc();\n      var test = loc();\n      after = loc();\n\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n\n      break;\n\n    case \"ForStatement\":\n      head = loc();\n      var update = loc();\n      after = loc();\n\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n\n      self.mark(head);\n\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {\n        // No test means continue unconditionally.\n      }\n\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n\n      self.mark(update);\n\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n\n      self.jump(head);\n\n      self.mark(after);\n\n      break;\n\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n\n    case \"ForInStatement\":\n      head = loc();\n      after = loc();\n\n      var keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n\n      self.mark(head);\n\n      var keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(keyIterNextFn, [])), t.identifier(\"done\"), false), after);\n\n      self.emitAssign(stmt.left, t.memberExpression(keyInfoTmpVar, t.identifier(\"value\"), false));\n\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n\n      self.jump(head);\n\n      self.mark(after);\n\n      break;\n\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n\n      break;\n\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n\n      break;\n\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n\n      after = loc();\n      var defaultLoc = loc();\n      var condition = defaultLoc;\n      var caseLocs = [];\n\n      // If there are no cases, .cases might be undefined.\n      var cases = stmt.cases || [];\n\n      for (var i = cases.length - 1; i >= 0; --i) {\n        var c = cases[i];\n        t.assertSwitchCase(c);\n\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", disc, c.test), caseLocs[i] = loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n\n      var discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          var i = casePath.key;\n          self.mark(caseLocs[i]);\n\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n\n      self.mark(after);\n      if (defaultLoc.value === -1) {\n        self.mark(defaultLoc);\n        _assert2.default.strictEqual(after.value, defaultLoc.value);\n      }\n\n      break;\n\n    case \"IfStatement\":\n      var elseLoc = stmt.alternate && loc();\n      after = loc();\n\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n\n      self.explodeStatement(path.get(\"consequent\"));\n\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n\n      self.mark(after);\n\n      break;\n\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n\n      break;\n\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n\n    case \"TryStatement\":\n      after = loc();\n\n      var handler = stmt.handler;\n\n      var catchLoc = handler && loc();\n      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n\n      var finallyLoc = stmt.finalizer && loc();\n      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n\n      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n\n          self.updateContextPrevLoc(self.mark(catchLoc));\n\n          var bodyPath = path.get(\"handler.body\");\n          var safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n\n          bodyPath.traverse(catchParamVisitor, {\n            safeParam: safeParam,\n            catchParamName: handler.param.name\n          });\n\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n\n      self.mark(after);\n\n      break;\n\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n\n      break;\n\n    default:\n      throw new Error(\"unknown Statement of type \" + (0, _stringify2.default)(stmt.type));\n  }\n};\n\nvar catchParamVisitor = {\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.safeParam);\n    }\n  },\n\n  Scope: function Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    _assert2.default.ok(false, \"invalid completion record: \" + (0, _stringify2.default)(record));\n  }\n\n  _assert2.default.notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n\n  var abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = record.target;\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = record.value;\n    }\n  }\n\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\n\nfunction isValidCompletion(record) {\n  var type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && t.isLiteral(record.target);\n  }\n\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n}\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function () {\n  return t.numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function (loc) {\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      _assert2.default.strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function (path, ignoreResult) {\n  var expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  var self = this;\n  var result = void 0; // Used optionally by several cases below.\n  var after = void 0;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    _assert2.default.ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n\n    var result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {\n      // Side effects already emitted above.\n\n    } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(tempVar || self.makeTempVar(), result);\n    }\n    return result;\n  }\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? explodeViaTempVar(null, path.get(\"property\")) : expr.property, expr.computed));\n\n    case \"CallExpression\":\n      var calleePath = path.get(\"callee\");\n      var argsPath = path.get(\"arguments\");\n\n      var newCallee = void 0;\n      var newArgs = [];\n\n      var hasLeapingArgs = false;\n      argsPath.forEach(function (argPath) {\n        hasLeapingArgs = hasLeapingArgs || meta.containsLeap(argPath.node);\n      });\n\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n\n          var newObject = explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"));\n\n          var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get(\"property\")) : calleePath.node.property;\n\n          newArgs.unshift(newObject);\n\n          newCallee = t.memberExpression(t.memberExpression(newObject, newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = explodeViaTempVar(null, calleePath);\n\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), newCallee]);\n        }\n      }\n\n      argsPath.forEach(function (argPath) {\n        newArgs.push(explodeViaTempVar(null, argPath));\n      });\n\n      return finish(t.callExpression(newCallee, newArgs));\n\n    case \"NewExpression\":\n      return finish(t.newExpression(explodeViaTempVar(null, path.get(\"callee\")), path.get(\"arguments\").map(function (argPath) {\n        return explodeViaTempVar(null, argPath);\n      })));\n\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get(\"value\")), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        return explodeViaTempVar(null, elemPath);\n      })));\n\n    case \"SequenceExpression\":\n      var lastIndex = expr.expressions.length - 1;\n\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n\n      return result;\n\n    case \"LogicalExpression\":\n      after = loc();\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      var left = explodeViaTempVar(result, path.get(\"left\"));\n\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        _assert2.default.strictEqual(expr.operator, \"||\");\n        self.jumpIf(left, after);\n      }\n\n      explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n\n      self.mark(after);\n\n      return result;\n\n    case \"ConditionalExpression\":\n      var elseLoc = loc();\n      after = loc();\n      var test = self.explodeExpression(path.get(\"test\"));\n\n      self.jumpIfNot(test, elseLoc);\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n      self.jump(after);\n\n      self.mark(elseLoc);\n      explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n\n      self.mark(after);\n\n      return result;\n\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get(\"left\")), explodeViaTempVar(null, path.get(\"right\"))));\n\n    case \"AssignmentExpression\":\n      return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n\n    case \"YieldExpression\":\n      after = loc();\n      var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n      if (arg && expr.delegate) {\n        var _result = self.makeTempVar();\n\n        self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(_result.property.name), after])));\n\n        self.mark(after);\n\n        return _result;\n      }\n\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      self.emit(t.returnStatement(arg || null));\n      self.mark(after);\n\n      return self.contextProperty(\"sent\");\n\n    default:\n      throw new Error(\"unknown Expression of type \" + (0, _stringify2.default)(expr.type));\n  }\n};"]}