{"version":3,"sources":["replaceShorthandObjectMethod.js"],"names":["exports","__esModule","default","replaceShorthandObjectMethod","_babelTypes","require","t","_interopRequireWildcard","_util","util","obj","newObj","key","Object","prototype","hasOwnProperty","call","path","node","isFunction","Error","isObjectMethod","generator","parameters","params","map","param","cloneDeep","functionExpression","body","async","replaceWithOrRemove","objectProperty","computed","get"],"mappings":"AAAA;;;;;;AAEAA,YAAQC,UAAR,GAAqB,IAArB;AACAD,YAAQE,OAAR,GAAkBC,4BAAlB;;AAEA,QAAIC,cAAcC,QAAQ,qBAAR,CAAlB;;AAEA,QAAIC,IAAIC,wBAAwBH,WAAxB,CAAR;;AAEA,QAAII,QAAQH,QAAQ,QAAR,CAAZ;;AAEA,QAAII,OAAOF,wBAAwBC,KAAxB,CAAX;;AAEA,aAASD,uBAAT,CAAiCG,GAAjC,EAAsC;AAAE,UAAIA,OAAOA,IAAIT,UAAf,EAA2B;AAAE,eAAOS,GAAP;AAAa,OAA1C,MAAgD;AAAE,YAAIC,SAAS,EAAb,CAAiB,IAAID,OAAO,IAAX,EAAiB;AAAE,eAAK,IAAIE,GAAT,IAAgBF,GAAhB,EAAqB;AAAE,gBAAIG,OAAOC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,GAArC,EAA0CE,GAA1C,CAAJ,EAAoDD,OAAOC,GAAP,IAAcF,IAAIE,GAAJ,CAAd;AAAyB;AAAE,SAACD,OAAOT,OAAP,GAAiBQ,GAAjB,CAAsB,OAAOC,MAAP;AAAgB;AAAE;;AAE7Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAASR,4BAAT,CAAsCc,IAAtC,EAA4C;AAC1C,UAAI,CAACA,KAAKC,IAAN,IAAc,CAACZ,EAAEa,UAAF,CAAaF,KAAKC,IAAlB,CAAnB,EAA4C;AAC1C,cAAM,IAAIE,KAAJ,CAAU,6EAAV,CAAN;AACD;;AAED;AACA;AACA,UAAI,CAACd,EAAEe,cAAF,CAAiBJ,KAAKC,IAAtB,CAAL,EAAkC;AAChC,eAAOD,IAAP;AACD;;AAED;AACA,UAAI,CAACA,KAAKC,IAAL,CAAUI,SAAf,EAA0B;AACxB,eAAOL,IAAP;AACD;;AAED,UAAIM,aAAaN,KAAKC,IAAL,CAAUM,MAAV,CAAiBC,GAAjB,CAAqB,UAAUC,KAAV,EAAiB;AACrD,eAAOpB,EAAEqB,SAAF,CAAYD,KAAZ,CAAP;AACD,OAFgB,CAAjB;;AAIA,UAAIE,qBAAqBtB,EAAEsB,kBAAF,CAAqB,IAArB,EAA2B;AACpDL,gBADyB,EACb;AACZjB,QAAEqB,SAAF,CAAYV,KAAKC,IAAL,CAAUW,IAAtB,CAFyB,EAEI;AAC7BZ,WAAKC,IAAL,CAAUI,SAHe,EAGJL,KAAKC,IAAL,CAAUY,KAHN,CAAzB;;AAKArB,WAAKsB,mBAAL,CAAyBd,IAAzB,EAA+BX,EAAE0B,cAAF,CAAiB1B,EAAEqB,SAAF,CAAYV,KAAKC,IAAL,CAAUN,GAAtB,CAAjB,EAA6C;AAC5EgB,wBAD+B,EACX;AACpBX,WAAKC,IAAL,CAAUe,QAFqB,EAEX;AACpB,WAH+B,CAGzB;AAHyB,OAA/B;;AAMA;AACA;AACA;AACA;AACA,aAAOhB,KAAKiB,GAAL,CAAS,OAAT,CAAP;AACD","file":"replaceShorthandObjectMethod.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = replaceShorthandObjectMethod;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _util = require(\"./util\");\n\nvar util = _interopRequireWildcard(_util);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\nfunction replaceShorthandObjectMethod(path) {\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  }\n\n  // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  }\n\n  // this function only replaces generators.\n  if (!path.node.generator) {\n    return path;\n  }\n\n  var parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  });\n\n  var functionExpression = t.functionExpression(null, // id\n  parameters, // params\n  t.cloneDeep(path.node.body), // body\n  path.node.generator, path.node.async);\n\n  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), // key\n  functionExpression, //value\n  path.node.computed, // computed\n  false // shorthand\n  ));\n\n  // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n  return path.get(\"value\");\n}"]}