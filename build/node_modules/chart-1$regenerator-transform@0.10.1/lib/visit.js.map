{"version":3,"sources":["visit.js"],"names":["_assert","require","_assert2","_interopRequireDefault","_babelTypes","t","_interopRequireWildcard","_hoist","_emit","_replaceShorthandObjectMethod","_replaceShorthandObjectMethod2","_util","util","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","default","exports","visitor","Function","exit","path","state","node","generator","async","opts","asyncGenerators","generators","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","get","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","body","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","hoist","didRenameArguments","renameArguments","variableDeclaration","argumentIdentifier","_shadowedFunctionLiteral","declarations","variableDeclarator","emitter","Emitter","explode","wrapArgs","getContextFunction","nullLiteral","thisExpression","tryLocsList","getTryLocsList","wrapCall","callExpression","runtimeProperty","returnStatement","blockStatement","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","requeue","funPath","assertFunction","parent","isFunctionDeclaration","getMarkedFunctionId","getMarkInfo","makeAccessor","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","funcPath","argumentsVisitor","FunctionExpressionFunctionDeclaration","skip","Identifier","isReference","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"mappings":"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","file":"visit.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n\"use strict\";\n\nvar _assert = require(\"assert\");\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = require(\"./replaceShorthandObjectMethod\");\n\nvar _replaceShorthandObjectMethod2 = _interopRequireDefault(_replaceShorthandObjectMethod);\n\nvar _util = require(\"./util\");\n\nvar util = _interopRequireWildcard(_util);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.visitor = {\n  Function: {\n    exit: function exit(path, state) {\n      var node = path.node;\n\n      if (node.generator) {\n        if (node.async) {\n          // Async generator\n          if (state.opts.asyncGenerators === false) return;\n        } else {\n          // Plain generator\n          if (state.opts.generators === false) return;\n        }\n      } else if (node.async) {\n        // Async function\n        if (state.opts.async === false) return;\n      } else {\n        // Not a generator or async function.\n        return;\n      }\n\n      // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n      path = (0, _replaceShorthandObjectMethod2.default)(path);\n      node = path.node;\n\n      var contextId = path.scope.generateUidIdentifier(\"context\");\n      var argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      var bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      var outerBody = [];\n      var innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function (childPath) {\n        var node = childPath.node;\n        if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n          // Babylon represents directives like \"use strict\" as elements\n          // of a bodyBlockPath.node.directives array, but they could just\n          // as easily be represented (by other parsers) as traditional\n          // string-literal-valued expression statements, so we need to\n          // handle that here. (#248)\n          outerBody.push(node);\n        } else if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      var outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      var innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      var vars = (0, _hoist.hoist)(path);\n\n      var didRenameArguments = renameArguments(path, argsId);\n      if (didRenameArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        var argumentIdentifier = t.identifier(\"arguments\");\n        // we need to do this as otherwise arguments in arrow functions gets hoisted\n        argumentIdentifier._shadowedFunctionLiteral = path;\n        vars.declarations.push(t.variableDeclarator(argsId, argumentIdentifier));\n      }\n\n      var emitter = new _emit.Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      var wrapArgs = [emitter.getContextFunction(innerFnId),\n      // Async functions that are not generators don't care about the\n      // outer function because they don't need it to be marked and don't\n      // inherit from its .prototype.\n      node.generator ? outerFnExpr : t.nullLiteral(), t.thisExpression()];\n\n      var tryLocsList = emitter.getTryLocsList();\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      }\n\n      var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n\n      var oldDirectives = bodyBlockPath.node.directives;\n      if (oldDirectives) {\n        // Babylon represents directives like \"use strict\" as elements of\n        // a bodyBlockPath.node.directives array. (#248)\n        node.body.directives = oldDirectives;\n      }\n\n      var wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    }\n  }\n};\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return node.id;\n}\n\nvar getMarkInfo = require(\"private\").makeAccessor();\n\nfunction getMarkedFunctionId(funPath) {\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n  _assert2.default.ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert2.default.strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [node.id]);\n\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert2.default.strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n\n  return markedId;\n}\n\nfunction renameArguments(funcPath, argsId) {\n  var state = {\n    didRenameArguments: false,\n    argsId: argsId\n  };\n\n  funcPath.traverse(argumentsVisitor, state);\n\n  // If the traversal replaced any arguments references, then we need to\n  // alias the outer function's arguments binding (be it the implicit\n  // arguments object or some other parameter or variable) to the variable\n  // named by argsId.\n  return state.didRenameArguments;\n}\n\nvar argumentsVisitor = {\n  \"FunctionExpression|FunctionDeclaration\": function FunctionExpressionFunctionDeclaration(path) {\n    path.skip();\n  },\n\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.argsId);\n      state.didRenameArguments = true;\n    }\n  }\n};\n\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      util.replaceWithOrRemove(path, t.memberExpression(this.context, t.identifier(\"_sent\")));\n    }\n  }\n};\n\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function AwaitExpression(path) {\n    // Convert await expressions to yield expressions.\n    var argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};"]}