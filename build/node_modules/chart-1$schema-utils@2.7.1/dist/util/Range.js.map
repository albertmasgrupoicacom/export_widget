{"version":3,"sources":["Range.js"],"names":["Range","getOperator","side","exclusive","formatRight","value","logic","formatLeft","formatRange","start","end","startExclusive","endExclusive","result","getRangeValue","values","minMax","Infinity","j","predicate","i","length","constructor","_left","_right","left","push","right","format","leftExclusive","rightExclusive","Number","isFinite","realStart","realEnd","module","exports"],"mappings":"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","file":"Range.js","sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === 'left') {\n      return exclusive ? '>' : '>=';\n    }\n\n    return exclusive ? '<' : '<=';\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('right', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('left', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = 'should be';\n    result += ` ${Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? 'and' : 'or';\n    result += ` ${Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return '';\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? '' : '!'}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"]}