{"version":3,"sources":["ValidationError.js"],"names":["Object","defineProperty","exports","value","default","stringHints","numberHints","require","SPECIFICITY","type","not","oneOf","anyOf","if","enum","const","instanceof","required","pattern","patternRequired","format","formatMinimum","formatMaximum","minimum","exclusiveMinimum","maximum","exclusiveMaximum","multipleOf","uniqueItems","contains","minLength","maxLength","minItems","maxItems","minProperties","maxProperties","dependencies","propertyNames","additionalItems","additionalProperties","absolutePath","filterMax","array","fn","evaluatedMax","reduce","max","item","Math","filter","filterChildren","children","newChildren","error","dataPath","length","keyword","findAllChildren","schemaPaths","i","predicate","schemaPath","indexOf","every","refs","extractRefs","childrenStart","slice","concat","schema","Array","isArray","map","$ref","s","groupChildrenByFirstChild","result","child","push","assign","reverse","indent","str","prefix","replace","hasNotInSchema","findFirstTypedSchema","canApplyNot","typedSchema","likeNumber","likeInteger","likeString","likeNull","likeBoolean","isObject","maybeObj","likeArray","items","likeObject","properties","patternProperties","getArticle","test","getSchemaNonTypes","formatHints","hints","join","getHints","logic","ValidationError","Error","constructor","errors","configuration","name","headerNameFromSchema","baseDataPathFromSchema","title","baseDataPath","splittedTitleFromSchema","match","headerName","postFormatter","header","message","formatValidationErrors","captureStackTrace","getSchemaPart","path","newPath","split","schemaPart","inner","formatSchema","prevSchemas","newLogic","formatInnerSchema","innerSchema","addSelf","includes","needApplyLogicHere","values","JSON","stringify","allOf","ifValue","then","thenValue","else","elseValue","hasAdditionalItems","Boolean","keys","allProperties","Set","objectStructure","property","isRequired","forEach","dependencyName","dependency","dep","getSchemaPartText","additionalPath","needDot","schemaText","description","getSchemaPartDescription","formatValidationError","errorDataPath","parentSchema","params","comparison","limit","missingPattern","data","missingProperty","hasProperty","additionalProperty","deps","trim","propertyName","postfix","schemaOutput","lastChild","remainingChildren","filteredChildren","nestedError","failingKeyword","ErrorInJSON","formattedError","_default"],"mappings":"AAAA;;;;;;AAEAA,WAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,aAAO;AADoC,KAA7C;AAGAD,YAAQE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,UAAM;AACJC,iBADI;AAEJC;AAFI,QAGFC,QAAQ,cAAR,CAHJ;AAIA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAGA,UAAMC,cAAc;AAClBC,YAAM,CADY;AAElBC,WAAK,CAFa;AAGlBC,aAAO,CAHW;AAIlBC,aAAO,CAJW;AAKlBC,UAAI,CALc;AAMlBC,YAAM,CANY;AAOlBC,aAAO,CAPW;AAQlBC,kBAAY,CARM;AASlBC,gBAAU,CATQ;AAUlBC,eAAS,CAVS;AAWlBC,uBAAiB,CAXC;AAYlBC,cAAQ,CAZU;AAalBC,qBAAe,CAbG;AAclBC,qBAAe,CAdG;AAelBC,eAAS,CAfS;AAgBlBC,wBAAkB,CAhBA;AAiBlBC,eAAS,CAjBS;AAkBlBC,wBAAkB,CAlBA;AAmBlBC,kBAAY,CAnBM;AAoBlBC,mBAAa,CApBK;AAqBlBC,gBAAU,CArBQ;AAsBlBC,iBAAW,CAtBO;AAuBlBC,iBAAW,CAvBO;AAwBlBC,gBAAU,CAxBQ;AAyBlBC,gBAAU,CAzBQ;AA0BlBC,qBAAe,CA1BG;AA2BlBC,qBAAe,CA3BG;AA4BlBC,oBAAc,CA5BI;AA6BlBC,qBAAe,CA7BG;AA8BlBC,uBAAiB,CA9BC;AA+BlBC,4BAAsB,CA/BJ;AAgClBC,oBAAc;AAhCI,KAApB;AAkCA;;;;;;;AAOA,aAASC,SAAT,CAAmBC,KAAnB,EAA0BC,EAA1B,EAA8B;AAC5B,YAAMC,eAAeF,MAAMG,MAAN,CAAa,CAACC,GAAD,EAAMC,IAAN,KAAeC,KAAKF,GAAL,CAASA,GAAT,EAAcH,GAAGI,IAAH,CAAd,CAA5B,EAAqD,CAArD,CAArB;AACA,aAAOL,MAAMO,MAAN,CAAaF,QAAQJ,GAAGI,IAAH,MAAaH,YAAlC,CAAP;AACD;AACD;;;;;;AAOA,aAASM,cAAT,CAAwBC,QAAxB,EAAkC;AAChC,UAAIC,cAAcD,QAAlB;AACAC,oBAAcX,UAAUW,WAAV;AACd;;;;;AAKAC,eAASA,MAAMC,QAAN,GAAiBD,MAAMC,QAAN,CAAeC,MAAhC,GAAyC,CANpC,CAAd;AAOAH,oBAAcX,UAAUW,WAAV;AACd;;;;AAIAC,eAAS7C;AACT;AACA6C,YAAMG,OAFG,KAES,CAPJ,CAAd;AAQA,aAAOJ,WAAP;AACD;AACD;;;;;;;AAQA,aAASK,eAAT,CAAyBN,QAAzB,EAAmCO,WAAnC,EAAgD;AAC9C,UAAIC,IAAIR,SAASI,MAAT,GAAkB,CAA1B;;AAEA,YAAMK;AACN;;;;AAIAC,oBAAcV,SAASQ,CAAT,EAAYE,UAAZ,CAAuBC,OAAvB,CAA+BD,UAA/B,MAA+C,CAL7D;;AAOA,aAAOF,IAAI,CAAC,CAAL,IAAU,CAACD,YAAYK,KAAZ,CAAkBH,SAAlB,CAAlB,EAAgD;AAC9C,YAAIT,SAASQ,CAAT,EAAYH,OAAZ,KAAwB,OAAxB,IAAmCL,SAASQ,CAAT,EAAYH,OAAZ,KAAwB,OAA/D,EAAwE;AACtE,gBAAMQ,OAAOC,YAAYd,SAASQ,CAAT,CAAZ,CAAb;AACA,gBAAMO,gBAAgBT,gBAAgBN,SAASgB,KAAT,CAAe,CAAf,EAAkBR,CAAlB,CAAhB,EAAsCK,KAAKI,MAAL,CAAYjB,SAASQ,CAAT,EAAYE,UAAxB,CAAtC,CAAtB;AACAF,cAAIO,gBAAgB,CAApB;AACD,SAJD,MAIO;AACLP,eAAK,CAAL;AACD;AACF;;AAED,aAAOA,IAAI,CAAX;AACD;AACD;;;;;;AAOA,aAASM,WAAT,CAAqBZ,KAArB,EAA4B;AAC1B,YAAM;AACJgB;AADI,UAEFhB,KAFJ;;AAIA,UAAI,CAACiB,MAAMC,OAAN,CAAcF,MAAd,CAAL,EAA4B;AAC1B,eAAO,EAAP;AACD;;AAED,aAAOA,OAAOG,GAAP,CAAW,CAAC;AACjBC;AADiB,OAAD,KAEZA,IAFC,EAEKxB,MAFL,CAEYyB,KAAKA,CAFjB,CAAP;AAGD;AACD;;;;;;AAOA,aAASC,yBAAT,CAAmCxB,QAAnC,EAA6C;AAC3C,YAAMyB,SAAS,EAAf;AACA,UAAIjB,IAAIR,SAASI,MAAT,GAAkB,CAA1B;;AAEA,aAAOI,IAAI,CAAX,EAAc;AACZ,cAAMkB,QAAQ1B,SAASQ,CAAT,CAAd;;AAEA,YAAIkB,MAAMrB,OAAN,KAAkB,OAAlB,IAA6BqB,MAAMrB,OAAN,KAAkB,OAAnD,EAA4D;AAC1D,gBAAMQ,OAAOC,YAAYY,KAAZ,CAAb;AACA,gBAAMX,gBAAgBT,gBAAgBN,SAASgB,KAAT,CAAe,CAAf,EAAkBR,CAAlB,CAAhB,EAAsCK,KAAKI,MAAL,CAAYS,MAAMhB,UAAlB,CAAtC,CAAtB;;AAEA,cAAIK,kBAAkBP,CAAtB,EAAyB;AACvBiB,mBAAOE,IAAP,CAAY9E,OAAO+E,MAAP,CAAc,EAAd,EAAkBF,KAAlB,EAAyB;AACnC1B,wBAAUA,SAASgB,KAAT,CAAeD,aAAf,EAA8BP,CAA9B;AADyB,aAAzB,CAAZ;AAGAA,gBAAIO,aAAJ;AACD,WALD,MAKO;AACLU,mBAAOE,IAAP,CAAYD,KAAZ;AACD;AACF,SAZD,MAYO;AACLD,iBAAOE,IAAP,CAAYD,KAAZ;AACD;;AAEDlB,aAAK,CAAL;AACD;;AAED,UAAIA,MAAM,CAAV,EAAa;AACXiB,eAAOE,IAAP,CAAY3B,SAASQ,CAAT,CAAZ;AACD;;AAED,aAAOiB,OAAOI,OAAP,EAAP;AACD;AACD;;;;;;AAOA,aAASC,MAAT,CAAgBC,GAAhB,EAAqBC,MAArB,EAA6B;AAC3B,aAAOD,IAAIE,OAAJ,CAAY,UAAZ,EAAyB,KAAID,MAAO,EAApC,CAAP;AACD;AACD;;;;;AAMA,aAASE,cAAT,CAAwBhB,MAAxB,EAAgC;AAC9B,aAAO,CAAC,CAACA,OAAO3D,GAAhB;AACD;AACD;;;;;AAMA,aAAS4E,oBAAT,CAA8BjB,MAA9B,EAAsC;AACpC,UAAIgB,eAAehB,MAAf,CAAJ,EAA4B;AAC1B,eAAOiB,qBAAqBjB,OAAO3D,GAA5B,CAAP;AACD;;AAED,aAAO2D,MAAP;AACD;AACD;;;;;AAMA,aAASkB,WAAT,CAAqBlB,MAArB,EAA6B;AAC3B,YAAMmB,cAAcF,qBAAqBjB,MAArB,CAApB;AACA,aAAOoB,WAAWD,WAAX,KAA2BE,YAAYF,WAAZ,CAA3B,IAAuDG,WAAWH,WAAX,CAAvD,IAAkFI,SAASJ,WAAT,CAAlF,IAA2GK,YAAYL,WAAZ,CAAlH;AACD;AACD;;;;;AAMA,aAASM,QAAT,CAAkBC,QAAlB,EAA4B;AAC1B,aAAO,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,aAAa,IAApD;AACD;AACD;;;;;AAMA,aAASN,UAAT,CAAoBpB,MAApB,EAA4B;AAC1B,aAAOA,OAAO5D,IAAP,KAAgB,QAAhB,IAA4B,OAAO4D,OAAO9C,OAAd,KAA0B,WAAtD,IAAqE,OAAO8C,OAAO7C,gBAAd,KAAmC,WAAxG,IAAuH,OAAO6C,OAAO5C,OAAd,KAA0B,WAAjJ,IAAgK,OAAO4C,OAAO3C,gBAAd,KAAmC,WAAnM,IAAkN,OAAO2C,OAAO1C,UAAd,KAA6B,WAAtP;AACD;AACD;;;;;AAMA,aAAS+D,WAAT,CAAqBrB,MAArB,EAA6B;AAC3B,aAAOA,OAAO5D,IAAP,KAAgB,SAAhB,IAA6B,OAAO4D,OAAO9C,OAAd,KAA0B,WAAvD,IAAsE,OAAO8C,OAAO7C,gBAAd,KAAmC,WAAzG,IAAwH,OAAO6C,OAAO5C,OAAd,KAA0B,WAAlJ,IAAiK,OAAO4C,OAAO3C,gBAAd,KAAmC,WAApM,IAAmN,OAAO2C,OAAO1C,UAAd,KAA6B,WAAvP;AACD;AACD;;;;;AAMA,aAASgE,UAAT,CAAoBtB,MAApB,EAA4B;AAC1B,aAAOA,OAAO5D,IAAP,KAAgB,QAAhB,IAA4B,OAAO4D,OAAOvC,SAAd,KAA4B,WAAxD,IAAuE,OAAOuC,OAAOtC,SAAd,KAA4B,WAAnG,IAAkH,OAAOsC,OAAOnD,OAAd,KAA0B,WAA5I,IAA2J,OAAOmD,OAAOjD,MAAd,KAAyB,WAApL,IAAmM,OAAOiD,OAAOhD,aAAd,KAAgC,WAAnO,IAAkP,OAAOgD,OAAO/C,aAAd,KAAgC,WAAzR;AACD;AACD;;;;;AAMA,aAASuE,WAAT,CAAqBxB,MAArB,EAA6B;AAC3B,aAAOA,OAAO5D,IAAP,KAAgB,SAAvB;AACD;AACD;;;;;AAMA,aAASuF,SAAT,CAAmB3B,MAAnB,EAA2B;AACzB,aAAOA,OAAO5D,IAAP,KAAgB,OAAhB,IAA2B,OAAO4D,OAAOrC,QAAd,KAA2B,QAAtD,IAAkE,OAAOqC,OAAOpC,QAAd,KAA2B,QAA7F,IAAyG,OAAOoC,OAAOzC,WAAd,KAA8B,WAAvI,IAAsJ,OAAOyC,OAAO4B,KAAd,KAAwB,WAA9K,IAA6L,OAAO5B,OAAO/B,eAAd,KAAkC,WAA/N,IAA8O,OAAO+B,OAAOxC,QAAd,KAA2B,WAAhR;AACD;AACD;;;;;AAMA,aAASqE,UAAT,CAAoB7B,MAApB,EAA4B;AAC1B,aAAOA,OAAO5D,IAAP,KAAgB,QAAhB,IAA4B,OAAO4D,OAAOnC,aAAd,KAAgC,WAA5D,IAA2E,OAAOmC,OAAOlC,aAAd,KAAgC,WAA3G,IAA0H,OAAOkC,OAAOpD,QAAd,KAA2B,WAArJ,IAAoK,OAAOoD,OAAO8B,UAAd,KAA6B,WAAjM,IAAgN,OAAO9B,OAAO+B,iBAAd,KAAoC,WAApP,IAAmQ,OAAO/B,OAAO9B,oBAAd,KAAuC,WAA1S,IAAyT,OAAO8B,OAAOjC,YAAd,KAA+B,WAAxV,IAAuW,OAAOiC,OAAOhC,aAAd,KAAgC,WAAvY,IAAsZ,OAAOgC,OAAOlD,eAAd,KAAkC,WAA/b;AACD;AACD;;;;;AAMA,aAASyE,QAAT,CAAkBvB,MAAlB,EAA0B;AACxB,aAAOA,OAAO5D,IAAP,KAAgB,MAAvB;AACD;AACD;;;;;AAMA,aAAS4F,UAAT,CAAoB5F,IAApB,EAA0B;AACxB,UAAI,YAAY6F,IAAZ,CAAiB7F,IAAjB,CAAJ,EAA4B;AAC1B,eAAO,IAAP;AACD;;AAED,aAAO,GAAP;AACD;AACD;;;;;AAMA,aAAS8F,iBAAT,CAA2BlC,MAA3B,EAAmC;AACjC,UAAI,CAACA,MAAL,EAAa;AACX,eAAO,EAAP;AACD;;AAED,UAAI,CAACA,OAAO5D,IAAZ,EAAkB;AAChB,YAAIgF,WAAWpB,MAAX,KAAsBqB,YAAYrB,MAAZ,CAA1B,EAA+C;AAC7C,iBAAO,6BAAP;AACD;;AAED,YAAIsB,WAAWtB,MAAX,CAAJ,EAAwB;AACtB,iBAAO,6BAAP;AACD;;AAED,YAAI2B,UAAU3B,MAAV,CAAJ,EAAuB;AACrB,iBAAO,4BAAP;AACD;;AAED,YAAI6B,WAAW7B,MAAX,CAAJ,EAAwB;AACtB,iBAAO,6BAAP;AACD;AACF;;AAED,aAAO,EAAP;AACD;AACD;;;;;AAMA,aAASmC,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,aAAOA,MAAMlD,MAAN,GAAe,CAAf,GAAoB,IAAGkD,MAAMC,IAAN,CAAW,IAAX,CAAiB,GAAxC,GAA6C,EAApD;AACD;AACD;;;;;;AAOA,aAASC,QAAT,CAAkBtC,MAAlB,EAA0BuC,KAA1B,EAAiC;AAC/B,UAAInB,WAAWpB,MAAX,KAAsBqB,YAAYrB,MAAZ,CAA1B,EAA+C;AAC7C,eAAO/D,YAAY+D,MAAZ,EAAoBuC,KAApB,CAAP;AACD,OAFD,MAEO,IAAIjB,WAAWtB,MAAX,CAAJ,EAAwB;AAC7B,eAAOhE,YAAYgE,MAAZ,EAAoBuC,KAApB,CAAP;AACD;;AAED,aAAO,EAAP;AACD;;AAED,UAAMC,eAAN,SAA8BC,KAA9B,CAAoC;AAClC;;;;;AAKAC,kBAAYC,MAAZ,EAAoB3C,MAApB,EAA4B4C,gBAAgB,EAA5C,EAAgD;AAC9C;AACA;;AAEA,aAAKC,IAAL,GAAY,iBAAZ;AACA;;AAEA,aAAKF,MAAL,GAAcA,MAAd;AACA;;AAEA,aAAK3C,MAAL,GAAcA,MAAd;AACA,YAAI8C,oBAAJ;AACA,YAAIC,sBAAJ;;AAEA,YAAI/C,OAAOgD,KAAP,KAAiB,CAACJ,cAAcC,IAAf,IAAuB,CAACD,cAAcK,YAAvD,CAAJ,EAA0E;AACxE,gBAAMC,0BAA0BlD,OAAOgD,KAAP,CAAaG,KAAb,CAAmB,aAAnB,CAAhC;;AAEA,cAAID,uBAAJ,EAA6B;AAC3B,gBAAI,CAACN,cAAcC,IAAnB,EAAyB;AACvB,iBAAGC,oBAAH,IAA2BI,uBAA3B;AACD;;AAED,gBAAI,CAACN,cAAcK,YAAnB,EAAiC;AAC/B,kBAAIF,sBAAJ,IAA8BG,uBAA9B;AACD;AACF;AACF;AACD;;AAGA,aAAKE,UAAL,GAAkBR,cAAcC,IAAd,IAAsBC,oBAAtB,IAA8C,QAAhE;AACA;;AAEA,aAAKG,YAAL,GAAoBL,cAAcK,YAAd,IAA8BF,sBAA9B,IAAwD,eAA5E;AACA;;AAEA,aAAKM,aAAL,GAAqBT,cAAcS,aAAd,IAA+B,IAApD;AACA,cAAMC,SAAU,WAAU,KAAKL,YAAa,YAAW,KAAKG,UAAW,+BAA8BpB,WAAW,KAAKiB,YAAhB,CAA8B,IAAG,KAAKA,YAAa,+CAAxJ;AACA;;AAEA,aAAKM,OAAL,GAAgB,GAAED,MAAO,GAAE,KAAKE,sBAAL,CAA4Bb,MAA5B,CAAoC,EAA/D;AACAF,cAAMgB,iBAAN,CAAwB,IAAxB,EAA8B,KAAKf,WAAnC;AACD;AACD;;;;;AAMAgB,oBAAcC,IAAd,EAAoB;AAClB,cAAMC,UAAUD,KAAKE,KAAL,CAAW,GAAX,CAAhB;AACA,YAAIC,aAAa,KAAK9D,MAAtB;;AAEA,aAAK,IAAIV,IAAI,CAAb,EAAgBA,IAAIsE,QAAQ1E,MAA5B,EAAoCI,GAApC,EAAyC;AACvC,gBAAMyE,QAAQD;AACd;AACAF,kBAAQtE,CAAR,CAFc,CAAd;;AAIA,cAAI,CAACyE,KAAL,EAAY;AACV;AACD;;AAEDD,uBAAaC,KAAb;AACD;;AAED,eAAOD,UAAP;AACD;AACD;;;;;;;AAQAE,mBAAahE,MAAb,EAAqBuC,QAAQ,IAA7B,EAAmC0B,cAAc,EAAjD,EAAqD;AACnD,YAAIC,WAAW3B,KAAf;;AAEA,cAAM4B;AACN;;;;;;AAMA,SAACC,WAAD,EAAcC,OAAd,KAA0B;AACxB,cAAI,CAACA,OAAL,EAAc;AACZ,mBAAO,KAAKL,YAAL,CAAkBI,WAAlB,EAA+BF,QAA/B,EAAyCD,WAAzC,CAAP;AACD;;AAED,cAAIA,YAAYK,QAAZ,CAAqBF,WAArB,CAAJ,EAAuC;AACrC,mBAAO,aAAP;AACD;;AAED,iBAAO,KAAKJ,YAAL,CAAkBI,WAAlB,EAA+BF,QAA/B,EAAyCD,YAAYlE,MAAZ,CAAmBC,MAAnB,CAAzC,CAAP;AACD,SAjBD;;AAmBA,YAAIgB,eAAehB,MAAf,KAA0B,CAAC6B,WAAW7B,MAAX,CAA/B,EAAmD;AACjD,cAAIkB,YAAYlB,OAAO3D,GAAnB,CAAJ,EAA6B;AAC3B6H,uBAAW,CAAC3B,KAAZ;AACA,mBAAO4B,kBAAkBnE,OAAO3D,GAAzB,CAAP;AACD;;AAED,gBAAMkI,qBAAqB,CAACvE,OAAO3D,GAAP,CAAWA,GAAvC;AACA,gBAAMyE,SAASyB,QAAQ,EAAR,GAAa,MAA5B;AACA2B,qBAAW,CAAC3B,KAAZ;AACA,iBAAOgC,qBAAqBzD,SAASqD,kBAAkBnE,OAAO3D,GAAzB,CAA9B,GAA8D8H,kBAAkBnE,OAAO3D,GAAzB,CAArE;AACD;;AAED;AACA;AACA2D,eAAOrD,UAFP,EAEmB;AACjB,gBAAM;AACJA,wBAAYb;AADR;AAGN;AACAkE,gBAJA;AAKA,gBAAMwE,SAAS,CAACvE,MAAMC,OAAN,CAAcpE,KAAd,CAAD,GAAwB,CAACA,KAAD,CAAxB,GAAkCA,KAAjD;AACA,iBAAO0I,OAAOrE,GAAP;AACP;;;;AAIAzB,kBAAQA,SAAS,UAAT,GAAsB,UAAtB,GAAmCA,IALpC,EAK0C2D,IAL1C,CAK+C,KAL/C,CAAP;AAMD;;AAED,YAAIrC,OAAOvD,IAAX,EAAiB;AACf;AACE;AACAuD,mBAAOvD,IAAP,CAAY0D,GAAZ,CAAgBzB,QAAQ+F,KAAKC,SAAL,CAAehG,IAAf,CAAxB,EAA8C2D,IAA9C,CAAmD,KAAnD;AAFF;AAID;;AAED,YAAI,OAAOrC,OAAOtD,KAAd,KAAwB,WAA5B,EAAyC;AACvC,iBAAO+H,KAAKC,SAAL,CAAe1E,OAAOtD,KAAtB,CAAP;AACD;;AAED,YAAIsD,OAAO1D,KAAX,EAAkB;AAChB;AACE;AACA0D,mBAAO1D,KAAP,CAAa6D,GAAb,CAAiBzB,QAAQyF,kBAAkBzF,IAAlB,EAAwB,IAAxB,CAAzB,EAAwD2D,IAAxD,CAA6D,KAA7D;AAFF;AAID;;AAED,YAAIrC,OAAOzD,KAAX,EAAkB;AAChB;AACE;AACAyD,mBAAOzD,KAAP,CAAa4D,GAAb,CAAiBzB,QAAQyF,kBAAkBzF,IAAlB,EAAwB,IAAxB,CAAzB,EAAwD2D,IAAxD,CAA6D,KAA7D;AAFF;AAID;;AAED,YAAIrC,OAAO2E,KAAX,EAAkB;AAChB;AACE;AACA3E,mBAAO2E,KAAP,CAAaxE,GAAb,CAAiBzB,QAAQyF,kBAAkBzF,IAAlB,EAAwB,IAAxB,CAAzB,EAAwD2D,IAAxD,CAA6D,KAA7D;AAFF;AAID;;AAED;AACA;AACArC,eAAOxD,EAFP,EAEW;AACT,gBAAM;AACJA,gBAAIoI,OADA;AAEJC,kBAAMC,SAFF;AAGJC,kBAAMC;AAHF;AAKN;AACAhF,gBANA;AAOA,iBAAQ,GAAE4E,UAAW,MAAKT,kBAAkBS,OAAlB,CAA2B,EAA3C,GAA+C,EAAG,GAAEE,YAAa,SAAQX,kBAAkBW,SAAlB,CAA6B,EAAlD,GAAsD,EAAG,GAAEE,YAAa,SAAQb,kBAAkBa,SAAlB,CAA6B,EAAlD,GAAsD,EAAG,EAAlL;AACD;;AAED,YAAIhF,OAAOI,IAAX,EAAiB;AACf,iBAAO+D,kBAAkB,KAAKT,aAAL,CAAmB1D,OAAOI,IAA1B,CAAlB,EAAmD,IAAnD,CAAP;AACD;;AAED,YAAIgB,WAAWpB,MAAX,KAAsBqB,YAAYrB,MAAZ,CAA1B,EAA+C;AAC7C,gBAAM,CAAC5D,IAAD,EAAO,GAAGgG,KAAV,IAAmBE,SAAStC,MAAT,EAAiBuC,KAAjB,CAAzB;AACA,gBAAM1B,MAAO,GAAEzE,IAAK,GAAEgG,MAAMlD,MAAN,GAAe,CAAf,GAAoB,IAAGiD,YAAYC,KAAZ,CAAmB,EAA1C,GAA8C,EAAG,EAAvE;AACA,iBAAOG,QAAQ1B,GAAR,GAAcuB,MAAMlD,MAAN,GAAe,CAAf,GAAoB,OAAM9C,IAAK,MAAKyE,GAAI,EAAxC,GAA6C,OAAMzE,IAAK,EAA7E;AACD;;AAED,YAAIkF,WAAWtB,MAAX,CAAJ,EAAwB;AACtB,gBAAM,CAAC5D,IAAD,EAAO,GAAGgG,KAAV,IAAmBE,SAAStC,MAAT,EAAiBuC,KAAjB,CAAzB;AACA,gBAAM1B,MAAO,GAAEzE,IAAK,GAAEgG,MAAMlD,MAAN,GAAe,CAAf,GAAoB,IAAGiD,YAAYC,KAAZ,CAAmB,EAA1C,GAA8C,EAAG,EAAvE;AACA,iBAAOG,QAAQ1B,GAAR,GAAcA,QAAQ,QAAR,GAAmB,YAAnB,GAAmC,gBAAeA,GAAI,EAA3E;AACD;;AAED,YAAIW,YAAYxB,MAAZ,CAAJ,EAAyB;AACvB,iBAAQ,GAAEuC,QAAQ,EAAR,GAAa,MAAO,SAA9B;AACD;;AAED,YAAIZ,UAAU3B,MAAV,CAAJ,EAAuB;AACrB;AACAkE,qBAAW,IAAX;AACA,gBAAM9B,QAAQ,EAAd;;AAEA,cAAI,OAAOpC,OAAOrC,QAAd,KAA2B,QAA/B,EAAyC;AACvCyE,kBAAM3B,IAAN,CAAY,8BAA6BT,OAAOrC,QAAS,QAAOqC,OAAOrC,QAAP,GAAkB,CAAlB,GAAsB,GAAtB,GAA4B,EAAG,EAA/F;AACD;;AAED,cAAI,OAAOqC,OAAOpC,QAAd,KAA2B,QAA/B,EAAyC;AACvCwE,kBAAM3B,IAAN,CAAY,6BAA4BT,OAAOpC,QAAS,QAAOoC,OAAOpC,QAAP,GAAkB,CAAlB,GAAsB,GAAtB,GAA4B,EAAG,EAA9F;AACD;;AAED,cAAIoC,OAAOzC,WAAX,EAAwB;AACtB6E,kBAAM3B,IAAN,CAAW,iCAAX;AACD;;AAED,gBAAMwE,qBAAqB,OAAOjF,OAAO/B,eAAd,KAAkC,WAAlC,IAAiDiH,QAAQlF,OAAO/B,eAAf,CAA5E;AACA,cAAI2D,QAAQ,EAAZ;;AAEA,cAAI5B,OAAO4B,KAAX,EAAkB;AAChB,gBAAI3B,MAAMC,OAAN,CAAcF,OAAO4B,KAArB,KAA+B5B,OAAO4B,KAAP,CAAa1C,MAAb,GAAsB,CAAzD,EAA4D;AAC1D0C,sBAAS;AACT;AACA5B,qBAAO4B,KAAP,CAAazB,GAAb,CAAiBzB,QAAQyF,kBAAkBzF,IAAlB,CAAzB,EAAkD2D,IAAlD,CAAuD,IAAvD,CAA6D,EAF7D;;AAIA,kBAAI4C,kBAAJ,EAAwB;AACtB,oBAAIjF,OAAO/B,eAAP,IAA0BwD,SAASzB,OAAO/B,eAAhB,CAA1B,IAA8DtC,OAAOwJ,IAAP,CAAYnF,OAAO/B,eAAnB,EAAoCiB,MAApC,GAA6C,CAA/G,EAAkH;AAChHkD,wBAAM3B,IAAN,CAAY,8BAA6B0D,kBAAkBnE,OAAO/B,eAAzB,CAA0C,EAAnF;AACD;AACF;AACF,aAVD,MAUO,IAAI+B,OAAO4B,KAAP,IAAgBjG,OAAOwJ,IAAP,CAAYnF,OAAO4B,KAAnB,EAA0B1C,MAA1B,GAAmC,CAAvD,EAA0D;AAC/D;AACA0C,sBAAS,GAAEuC,kBAAkBnE,OAAO4B,KAAzB,CAAgC,EAA3C;AACD,aAHM,MAGA;AACL;AACAA,sBAAQ,KAAR;AACD;AACF,WAlBD,MAkBO;AACL;AACAA,oBAAQ,KAAR;AACD;;AAED,cAAI5B,OAAOxC,QAAP,IAAmB7B,OAAOwJ,IAAP,CAAYnF,OAAOxC,QAAnB,EAA6B0B,MAA7B,GAAsC,CAA7D,EAAgE;AAC9DkD,kBAAM3B,IAAN,CAAY,gCAA+B,KAAKuD,YAAL,CAAkBhE,OAAOxC,QAAzB,CAAmC,OAA9E;AACD;;AAED,iBAAQ,IAAGoE,KAAM,GAAEqD,qBAAqB,OAArB,GAA+B,EAAG,IAAG7C,MAAMlD,MAAN,GAAe,CAAf,GAAoB,KAAIkD,MAAMC,IAAN,CAAW,IAAX,CAAiB,GAAzC,GAA8C,EAAG,EAAzG;AACD;;AAED,YAAIR,WAAW7B,MAAX,CAAJ,EAAwB;AACtB;AACAkE,qBAAW,IAAX;AACA,gBAAM9B,QAAQ,EAAd;;AAEA,cAAI,OAAOpC,OAAOnC,aAAd,KAAgC,QAApC,EAA8C;AAC5CuE,kBAAM3B,IAAN,CAAY,8BAA6BT,OAAOnC,aAAc,IAAGmC,OAAOnC,aAAP,GAAuB,CAAvB,GAA2B,YAA3B,GAA0C,UAAW,EAAtH;AACD;;AAED,cAAI,OAAOmC,OAAOlC,aAAd,KAAgC,QAApC,EAA8C;AAC5CsE,kBAAM3B,IAAN,CAAY,6BAA4BT,OAAOlC,aAAc,IAAGkC,OAAOnC,aAAP,IAAwBmC,OAAOnC,aAAP,GAAuB,CAA/C,GAAmD,YAAnD,GAAkE,UAAW,EAA7I;AACD;;AAED,cAAImC,OAAO+B,iBAAP,IAA4BpG,OAAOwJ,IAAP,CAAYnF,OAAO+B,iBAAnB,EAAsC7C,MAAtC,GAA+C,CAA/E,EAAkF;AAChF,kBAAM6C,oBAAoBpG,OAAOwJ,IAAP,CAAYnF,OAAO+B,iBAAnB,CAA1B;AACAK,kBAAM3B,IAAN,CAAY,iDAAgDsB,kBAAkB7C,MAAlB,GAA2B,CAA3B,GAA+B,GAA/B,GAAqC,EAAG,IAAG6C,kBAAkB5B,GAAlB,CAAsBtD,WAAW4H,KAAKC,SAAL,CAAe7H,OAAf,CAAjC,EAA0DwF,IAA1D,CAA+D,KAA/D,CAAsE,EAA7K;AACD;;AAED,gBAAMP,aAAa9B,OAAO8B,UAAP,GAAoBnG,OAAOwJ,IAAP,CAAYnF,OAAO8B,UAAnB,CAApB,GAAqD,EAAxE;AACA,gBAAMlF,WAAWoD,OAAOpD,QAAP,GAAkBoD,OAAOpD,QAAzB,GAAoC,EAArD;AACA,gBAAMwI,gBAAgB,CAAC,GAAG,IAAIC,GAAJ;AAC1B;AACA,aAAGtF,MAAH,CAAUnD,QAAV,EAAoBmD,MAApB,CAA2B+B,UAA3B,CAF0B,CAAJ,CAAtB;AAGA,gBAAMwD,kBAAkBF,cAAcjF,GAAd,CAAkBoF,YAAY;AACpD,kBAAMC,aAAa5I,SAAS0H,QAAT,CAAkBiB,QAAlB,CAAnB,CADoD,CACJ;AAChD;;AAEA,mBAAQ,GAAEA,QAAS,GAAEC,aAAa,EAAb,GAAkB,GAAI,EAA3C;AACD,WALuB,EAKrBzF,MALqB,CAKd,OAAOC,OAAO9B,oBAAd,KAAuC,WAAvC,IAAsDgH,QAAQlF,OAAO9B,oBAAf,CAAtD,GAA6F8B,OAAO9B,oBAAP,IAA+BuD,SAASzB,OAAO9B,oBAAhB,CAA/B,GAAuE,CAAE,UAASiG,kBAAkBnE,OAAO9B,oBAAzB,CAA+C,EAA1D,CAAvE,GAAsI,CAAC,GAAD,CAAnO,GAA2O,EAL7N,EAKiOmE,IALjO,CAKsO,IALtO,CAAxB;AAMA,gBAAM;AACJtE,wBADI;AAEJC,yBAFI;AAGJlB;AAHI;AAKN;AACAkD,gBANA;;AAQA,cAAIjC,YAAJ,EAAkB;AAChBpC,mBAAOwJ,IAAP,CAAYpH,YAAZ,EAA0B0H,OAA1B,CAAkCC,kBAAkB;AAClD,oBAAMC,aAAa5H,aAAa2H,cAAb,CAAnB;;AAEA,kBAAIzF,MAAMC,OAAN,CAAcyF,UAAd,CAAJ,EAA+B;AAC7BvD,sBAAM3B,IAAN,CAAY,eAAckF,WAAWzG,MAAX,GAAoB,CAApB,GAAwB,YAAxB,GAAuC,UAAW,IAAGyG,WAAWxF,GAAX,CAAeyF,OAAQ,IAAGA,GAAI,GAA9B,EAAkCvD,IAAlC,CAAuC,IAAvC,CAA6C,mBAAkBqD,cAAe,cAA7J;AACD,eAFD,MAEO;AACLtD,sBAAM3B,IAAN,CAAY,2CAA0C0D,kBAAkBwB,UAAlB,CAA8B,mBAAkBD,cAAe,cAArH;AACD;AACF,aARD;AASD;;AAED,cAAI1H,iBAAiBrC,OAAOwJ,IAAP,CAAYnH,aAAZ,EAA2BkB,MAA3B,GAAoC,CAAzD,EAA4D;AAC1DkD,kBAAM3B,IAAN,CAAY,0CAAyCgE,KAAKC,SAAL,CAAe1E,OAAOhC,aAAP,CAAqBjB,MAApC,CAA4C,EAAjG;AACD;;AAED,cAAID,mBAAmBA,gBAAgBoC,MAAhB,GAAyB,CAAhD,EAAmD;AACjDkD,kBAAM3B,IAAN,CAAY,yCAAwC3D,gBAAgBqD,GAAhB;AACpD;;;;AAIAzB,oBAAQ+F,KAAKC,SAAL,CAAehG,IAAf,CAL4C,CAKtB,EAL9B;AAMD;;AAED,iBAAQ,WAAU4G,kBAAmB,IAAGA,eAAgB,GAAtC,GAA2C,EAAG,IAAGlD,MAAMlD,MAAN,GAAe,CAAf,GAAoB,KAAIkD,MAAMC,IAAN,CAAW,IAAX,CAAiB,GAAzC,GAA8C,EAAG,EAApH;AACD;;AAED,YAAId,SAASvB,MAAT,CAAJ,EAAsB;AACpB,iBAAQ,GAAEuC,QAAQ,EAAR,GAAa,MAAO,MAA9B;AACD;;AAED,YAAItC,MAAMC,OAAN,CAAcF,OAAO5D,IAArB,CAAJ,EAAgC;AAC9B;AACA,iBAAQ,GAAE4D,OAAO5D,IAAP,CAAYiG,IAAZ,CAAiB,KAAjB,CAAwB,EAAlC;AACD,SA9OkD,CA8OjD;AACF;;AAEA;;AAGA,eAAOoC,KAAKC,SAAL,CAAe1E,MAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAAP;AACD;AACD;;;;;;;;AASA6F,wBAAkB/B,UAAlB,EAA8BgC,cAA9B,EAA8CC,UAAU,KAAxD,EAA+DxD,QAAQ,IAAvE,EAA6E;AAC3E,YAAI,CAACuB,UAAL,EAAiB;AACf,iBAAO,EAAP;AACD;;AAED,YAAI7D,MAAMC,OAAN,CAAc4F,cAAd,CAAJ,EAAmC;AACjC,eAAK,IAAIxG,IAAI,CAAb,EAAgBA,IAAIwG,eAAe5G,MAAnC,EAA2CI,GAA3C,EAAgD;AAC9C;AACA,kBAAMyE,QAAQD;AACd;AACAgC,2BAAexG,CAAf,CAFc,CAAd;;AAIA,gBAAIyE,KAAJ,EAAW;AACT;AACAD,2BAAaC,KAAb;AACD,aAHD,MAGO;AACL;AACD;AACF;AACF;;AAED,eAAOD,WAAW1D,IAAlB,EAAwB;AACtB;AACA0D,uBAAa,KAAKJ,aAAL,CAAmBI,WAAW1D,IAA9B,CAAb;AACD;;AAED,YAAI4F,aAAc,GAAE,KAAKhC,YAAL,CAAkBF,UAAlB,EAA8BvB,KAA9B,CAAqC,GAAEwD,UAAU,GAAV,GAAgB,EAAG,EAA9E;;AAEA,YAAIjC,WAAWmC,WAAf,EAA4B;AAC1BD,wBAAe,QAAOlC,WAAWmC,WAAY,EAA7C;AACD;;AAED,eAAOD,UAAP;AACD;AACD;;;;;AAMAE,+BAAyBpC,UAAzB,EAAqC;AACnC,YAAI,CAACA,UAAL,EAAiB;AACf,iBAAO,EAAP;AACD;;AAED,eAAOA,WAAW1D,IAAlB,EAAwB;AACtB;AACA0D,uBAAa,KAAKJ,aAAL,CAAmBI,WAAW1D,IAA9B,CAAb;AACD;;AAED,YAAI0D,WAAWmC,WAAf,EAA4B;AAC1B,iBAAQ,QAAOnC,WAAWmC,WAAY,EAAtC;AACD;;AAED,eAAO,EAAP;AACD;AACD;;;;;AAMAE,4BAAsBnH,KAAtB,EAA6B;AAC3B,cAAM;AACJG,iBADI;AAEJF,oBAAUmH;AAFN,YAGFpH,KAHJ;AAIA,cAAMC,WAAY,GAAE,KAAKgE,YAAa,GAAEmD,aAAc,EAAtD;;AAEA,gBAAQjH,OAAR;AACE,eAAK,MAAL;AACE;AACE,oBAAM;AACJkH,4BADI;AAEJC;AAFI,kBAGFtH,KAHJ,CADF,CAIa;;AAEX;AACA;AACAsH,qBAAOlK,IAFP;AAGE,qBAAK,QAAL;AACE,yBAAQ,GAAE6C,QAAS,gBAAe,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAApF;;AAEF,qBAAK,SAAL;AACE,yBAAQ,GAAEpH,QAAS,gBAAe,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAApF;;AAEF,qBAAK,QAAL;AACE,yBAAQ,GAAEpH,QAAS,gBAAe,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAApF;;AAEF,qBAAK,SAAL;AACE,yBAAQ,GAAEpH,QAAS,gBAAe,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAApF;;AAEF,qBAAK,OAAL;AACE,yBAAQ,GAAEpH,QAAS,yBAAwB,KAAK4G,iBAAL,CAAuBQ,YAAvB,CAAqC,EAAhF;;AAEF,qBAAK,QAAL;AACE,yBAAQ,GAAEpH,QAAS,0BAAyB,KAAK4G,iBAAL,CAAuBQ,YAAvB,CAAqC,EAAjF;;AAEF,qBAAK,MAAL;AACE,yBAAQ,GAAEpH,QAAS,gBAAe,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAApF;;AAEF;AACE,yBAAQ,GAAEpH,QAAS,gBAAe,KAAK4G,iBAAL,CAAuBQ,YAAvB,CAAqC,EAAvE;AAzBJ;AA2BD;;AAEH,eAAK,YAAL;AACE;AACE,oBAAM;AACJA;AADI,kBAEFrH,KAFJ;AAGA,qBAAQ,GAAEC,QAAS,6BAA4B,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAAjG;AACD;;AAEH,eAAK,SAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJnC;AADI;AAGN;AACAyJ,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,yBAAwBwF,KAAKC,SAAL,CAAe7H,OAAf,CAAwB,GAAEqF,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAApJ;AACD;;AAEH,eAAK,QAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJjC;AADI;AAGN;AACAuJ,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,wBAAuBwF,KAAKC,SAAL,CAAe3H,MAAf,CAAuB,GAAEmF,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAlJ;AACD;;AAEH,eAAK,eAAL;AACA,eAAK,eAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJuH,0BADI;AAEJC;AAFI;AAIN;AACAF,oBALA;AAMA,qBAAQ,GAAErH,QAAS,cAAasH,UAAW,IAAG9B,KAAKC,SAAL,CAAe8B,KAAf,CAAsB,GAAEtE,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAArJ;AACD;;AAEH,eAAK,SAAL;AACA,eAAK,SAAL;AACA,eAAK,kBAAL;AACA,eAAK,kBAAL;AACE;AACE,oBAAM;AACJA,4BADI;AAEJC;AAFI,kBAGFtH,KAHJ;AAIA,oBAAM;AACJuH,0BADI;AAEJC;AAFI;AAIN;AACAF,oBALA;AAMA,oBAAM,GAAG,GAAGlE,KAAN,IAAeE;AACrB;AACA+D,0BAFqB,EAEP,IAFO,CAArB;;AAIA,kBAAIjE,MAAMlD,MAAN,KAAiB,CAArB,EAAwB;AACtBkD,sBAAM3B,IAAN,CAAY,aAAY8F,UAAW,IAAGC,KAAM,EAA5C;AACD;;AAED,qBAAQ,GAAEvH,QAAS,IAAGmD,MAAMC,IAAN,CAAW,GAAX,CAAgB,GAAEH,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAvH;AACD;;AAEH,eAAK,YAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJ1B;AADI;AAGN;AACAgJ,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,0BAAyB3B,UAAW,GAAE4E,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAxI;AACD;;AAEH,eAAK,iBAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJyH;AADI;AAGN;AACAH,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,0CAAyCwF,KAAKC,SAAL,CAAe+B,cAAf,CAA+B,GAAEvE,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAA5K;AACD;;AAEH,eAAK,WAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;;AAMA,kBAAIE,UAAU,CAAd,EAAiB;AACf,uBAAQ,GAAEvH,QAAS,iCAAgCiD,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAlI;AACD;;AAED,oBAAMnH,SAASsH,QAAQ,CAAvB;AACA,qBAAQ,GAAEvH,QAAS,0BAAyBC,MAAO,aAAYA,SAAS,CAAT,GAAa,GAAb,GAAmB,EAAG,GAAEgD,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAtK;AACD;;AAEH,eAAK,UAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;;AAMA,kBAAIE,UAAU,CAAd,EAAiB;AACf,uBAAQ,GAAEvH,QAAS,gCAA+BiD,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAjI;AACD;;AAED,qBAAQ,GAAEpH,QAAS,+BAA8BuH,KAAM,SAAQtE,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAA9I;AACD;;AAEH,eAAK,eAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;;AAMA,kBAAIE,UAAU,CAAd,EAAiB;AACf,uBAAQ,GAAEvH,QAAS,iCAAgCiD,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAlI;AACD;;AAED,qBAAQ,GAAEpH,QAAS,+BAA8BuH,KAAM,cAAatE,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAnJ;AACD;;AAEH,eAAK,WAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;AAKA,oBAAM7H,MAAM+H,QAAQ,CAApB;AACA,qBAAQ,GAAEvH,QAAS,2BAA0BR,GAAI,aAAYA,MAAM,CAAN,GAAU,GAAV,GAAgB,EAAG,GAAEyD,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAjK;AACD;;AAEH,eAAK,UAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,8BAA6BuH,KAAM,SAAQtE,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAA7I;AACD;;AAEH,eAAK,eAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,8BAA6BuH,KAAM,cAAatE,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAlJ;AACD;;AAEH,eAAK,aAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJM;AADI;AAGN;AACAgH,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,iCAAgCD,MAAM0H,IAAN,CAAWpH,CAAX,CAAc,UAAS4C,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAzJ;AACD;;AAEH,eAAK,iBAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJwH;AADI;AAGN;AACAF,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,8BAA6BuH,KAAM,SAAQtE,kBAAkBmE,YAAlB,CAAgC,6BAA4B,KAAKR,iBAAL,CAAuBQ,YAAvB,CAAqC,EAA/J;AACD;;AAEH,eAAK,UAAL;AACE;AACE,oBAAM;AACJA;AADI,kBAEFrH,KAFJ;AAGA,qBAAQ,GAAEC,QAAS,iCAAgC,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,CAAC,UAAD,CAArC,CAAmD,QAAOnE,kBAAkBmE,YAAlB,CAAgC,GAA7I;AACD;;AAEH,eAAK,UAAL;AACE;AACE,oBAAM;AACJA,4BADI;AAEJC;AAFI,kBAGFtH,KAHJ;AAIA,oBAAM2H;AACN;AACAL,qBAAOK,eAAP,CAAuB5F,OAAvB,CAA+B,KAA/B,EAAsC,EAAtC,CAFA;AAGA,oBAAM6F,cAAcP,gBAAgBnB;AACpC;AACAmB,2BAAavE,UAAb;AACA;AACAuE,2BAAavE,UAAb,CAAwB6E,eAAxB,CAJoC,CAApC;AAKA,qBAAQ,GAAE1H,QAAS,yBAAwB0H,eAAgB,IAAGzE,kBAAkBmE,YAAlB,CAAgC,IAAGO,cAAe,gBAAe,KAAKf,iBAAL,CAAuBQ,YAAvB,EAAqC,CAAC,YAAD,EAAeM,eAAf,CAArC,CAAsE,EAApG,GAAwG,KAAKT,wBAAL,CAA8BG,YAA9B,CAA4C,EAArP;AACD;;AAEH,eAAK,sBAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJ6H;AADI;AAGN;AACAP,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,6BAA4B4H,kBAAmB,IAAG3E,kBAAkBmE,YAAlB,CAAgC,kCAAiC,KAAKR,iBAAL,CAAuBQ,YAAvB,CAAqC,EAA3K;AACD;;AAEH,eAAK,cAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJuG,wBADI;AAEJuB;AAFI;AAIN;AACAR,oBALA;AAMA,oBAAMvI,eAAe+I,KAAKjD,KAAL,CAAW,GAAX,EAAgB1D,GAAhB;AACrB;;;;AAIAyF,qBAAQ,IAAGA,IAAImB,IAAJ,EAAW,GALD,EAKK1E,IALL,CAKU,IALV,CAArB;AAMA,qBAAQ,GAAEpD,QAAS,2BAA0BlB,YAAa,mBAAkBwH,QAAS,eAAcrD,kBAAkBmE,YAAlB,CAAgC,IAAG,KAAKH,wBAAL,CAA8BG,YAA9B,CAA4C,EAAlL;AACD;;AAEH,eAAK,eAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD,4BAFI;AAGJrG;AAHI,kBAIFhB,KAJJ;AAKA,oBAAM;AACJgI;AADI;AAGN;AACAV,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,mBAAkB+H,YAAa,eAAc9E,kBAAkBmE,YAAlB,CAAgC,2CAA0C5B,KAAKC,SAAL,CAAe1E,OAAOjD,MAAtB,CAA8B,IAAG,KAAKmJ,wBAAL,CAA8BG,YAA9B,CAA4C,EAAvN;AACD;;AAEH,eAAK,MAAL;AACE;AACE,oBAAM;AACJA;AADI,kBAEFrH,KAFJ;;AAIA,kBAAIqH;AACJ;AACAA,2BAAa5J,IAFT;AAGJ;AACA4J,2BAAa5J,IAAb,CAAkByC,MAAlB,KAA6B,CAJ7B,EAIgC;AAC9B,uBAAQ,GAAED,QAAS,cAAa,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAAlF;AACD;;AAED,qBAAQ,GAAEpH,QAAS,6BAA4B,KAAK4G,iBAAL,CAAuBQ,YAAvB,CAAqC,EAApF;AACD;;AAEH,eAAK,OAAL;AACE;AACE,oBAAM;AACJA;AADI,kBAEFrH,KAFJ;AAGA,qBAAQ,GAAEC,QAAS,gCAA+B,KAAK4G,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,EAA4C,IAA5C,CAAkD,EAApG;AACD;;AAEH,eAAK,KAAL;AACE;AACE,oBAAMY,UAAUpF;AAChB;AACA7C,oBAAMqH,YAFU,IAEO,KAAI,KAAKR,iBAAL,CAAuB7G,MAAMqH,YAA7B,CAA2C,EAFtD,GAE0D,EAF1E;AAGA,oBAAMa,eAAe,KAAKrB,iBAAL,CAAuB7G,MAAMgB,MAA7B,EAAqC,KAArC,EAA4C,KAA5C,EAAmD,KAAnD,CAArB;;AAEA,kBAAIkB,YAAYlC,MAAMgB,MAAlB,CAAJ,EAA+B;AAC7B,uBAAQ,GAAEf,QAAS,kBAAiBiI,YAAa,GAAED,OAAQ,GAA3D;AACD;;AAED,oBAAM;AACJjH,sBADI;AAEJqG;AAFI,kBAGFrH,KAHJ;AAIA,qBAAQ,GAAEC,QAAS,kBAAiB,KAAK4G,iBAAL,CAAuB7F,MAAvB,EAA+B,KAA/B,EAAsC,IAAtC,CAA4C,GAAEqG,gBAAgBxE,WAAWwE,YAAX,CAAhB,GAA4C,KAAI,KAAKR,iBAAL,CAAuBQ,YAAvB,CAAqC,EAArF,GAAyF,EAAG,EAA9K;AACD;;AAEH,eAAK,OAAL;AACA,eAAK,OAAL;AACE;AACE,oBAAM;AACJA,4BADI;AAEJvH;AAFI,kBAGFE,KAHJ;;AAKA,kBAAIF,YAAYA,SAASI,MAAT,GAAkB,CAAlC,EAAqC;AACnC,oBAAIF,MAAMgB,MAAN,CAAad,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,wBAAMiI,YAAYrI,SAASA,SAASI,MAAT,GAAkB,CAA3B,CAAlB;AACA,wBAAMkI,oBAAoBtI,SAASgB,KAAT,CAAe,CAAf,EAAkBhB,SAASI,MAAT,GAAkB,CAApC,CAA1B;AACA,yBAAO,KAAKiH,qBAAL,CAA2BxK,OAAO+E,MAAP,CAAc,EAAd,EAAkByG,SAAlB,EAA6B;AAC7DrI,8BAAUsI,iBADmD;AAE7Df,kCAAc1K,OAAO+E,MAAP,CAAc,EAAd,EAAkB2F,YAAlB,EAAgCc,UAAUd,YAA1C;AAF+C,mBAA7B,CAA3B,CAAP;AAID;;AAED,oBAAIgB,mBAAmBxI,eAAeC,QAAf,CAAvB;;AAEA,oBAAIuI,iBAAiBnI,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,yBAAO,KAAKiH,qBAAL,CAA2BkB,iBAAiB,CAAjB,CAA3B,CAAP;AACD;;AAEDA,mCAAmB/G,0BAA0B+G,gBAA1B,CAAnB;AACA,uBAAQ,GAAEpI,QAAS,6BAA4B,KAAK4G,iBAAL,CAAuBQ,YAAvB,CAAqC,eAAcgB,iBAAiBlH,GAAjB;AAClG;;;;AAIAmH,+BAAgB,MAAK1G,OAAO,KAAKuF,qBAAL,CAA2BmB,WAA3B,CAAP,EAAgD,KAAhD,CAAuD,EALsB,EAKnBjF,IALmB,CAKd,IALc,CAKR,EAL1F;AAMD;;AAED,qBAAQ,GAAEpD,QAAS,6BAA4B,KAAK4G,iBAAL,CAAuBQ,YAAvB,CAAqC,EAApF;AACD;;AAEH,eAAK,IAAL;AACE;AACE,oBAAM;AACJC,sBADI;AAEJD;AAFI,kBAGFrH,KAHJ;AAIA,oBAAM;AACJuI;AADI;AAGN;AACAjB,oBAJA;AAKA,qBAAQ,GAAErH,QAAS,kBAAiBsI,cAAe,cAAa,KAAK1B,iBAAL,CAAuBQ,YAAvB,EAAqC,CAACkB,cAAD,CAArC,CAAuD,EAAvH;AACD;;AAEH,eAAK,cAAL;AACE;AACE,oBAAM;AACJhE,uBADI;AAEJ8C;AAFI,kBAGFrH,KAHJ;AAIA,qBAAQ,GAAEC,QAAS,KAAIsE,OAAQ,GAAE,KAAK2C,wBAAL,CAA8BG,YAA9B,CAA4C,EAA7E;AACD;;AAEH;;AAEA;AACE;AACE,oBAAM;AACJ9C,uBADI;AAEJ8C;AAFI,kBAGFrH,KAHJ;AAIA,oBAAMwI,cAAc/C,KAAKC,SAAL,CAAe1F,KAAf,EAAsB,IAAtB,EAA4B,CAA5B,CAApB,CALF,CAKsD;AACpD;;AAEA,qBAAQ,GAAEC,QAAS,IAAGsE,OAAQ,KAAIiE,WAAY,OAAM,KAAK3B,iBAAL,CAAuBQ,YAAvB,EAAqC,KAArC,CAA4C,EAAhG;AACD;AA7cL;AA+cD;AACD;;;;;AAMA7C,6BAAuBb,MAAvB,EAA+B;AAC7B,eAAOA,OAAOxC,GAAP,CAAWnB,SAAS;AACzB,cAAIyI,iBAAiB,KAAKtB,qBAAL,CAA2BnH,KAA3B,CAArB;;AAEA,cAAI,KAAKqE,aAAT,EAAwB;AACtBoE,6BAAiB,KAAKpE,aAAL,CAAmBoE,cAAnB,EAAmCzI,KAAnC,CAAjB;AACD;;AAED,iBAAQ,MAAK4B,OAAO6G,cAAP,EAAuB,KAAvB,CAA8B,EAA3C;AACD,SARM,EAQJpF,IARI,CAQC,IARD,CAAP;AASD;;AAr3BiC;;AAy3BpC,QAAIqF,WAAWlF,eAAf;AACA3G,YAAQE,OAAR,GAAkB2L,QAAlB","file":"ValidationError.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst {\n  stringHints,\n  numberHints\n} = require('./util/hints');\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/** @enum {number} */\n\n\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.dataPath ? error.dataPath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[\n  /** @type {keyof typeof SPECIFICITY} */\n  error.keyword] || 2);\n  return newChildren;\n}\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\n\n\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === 'anyOf' || children[i].keyword === 'oneOf') {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n\n  return i + 1;\n}\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\n\n\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n\n  while (i > 0) {\n    const child = children[i];\n\n    if (child.keyword === 'anyOf' || child.keyword === 'oneOf') {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n\n    i -= 1;\n  }\n\n  if (i === 0) {\n    result.push(children[i]);\n  }\n\n  return result.reverse();\n}\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\n\n\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\n\n\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n\n  return schema;\n}\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\n\n\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\n\n\nfunction isObject(maybeObj) {\n  return typeof maybeObj === 'object' && maybeObj !== null;\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNumber(schema) {\n  return schema.type === 'number' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeInteger(schema) {\n  return schema.type === 'integer' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeString(schema) {\n  return schema.type === 'string' || typeof schema.minLength !== 'undefined' || typeof schema.maxLength !== 'undefined' || typeof schema.pattern !== 'undefined' || typeof schema.format !== 'undefined' || typeof schema.formatMinimum !== 'undefined' || typeof schema.formatMaximum !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeBoolean(schema) {\n  return schema.type === 'boolean';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeArray(schema) {\n  return schema.type === 'array' || typeof schema.minItems === 'number' || typeof schema.maxItems === 'number' || typeof schema.uniqueItems !== 'undefined' || typeof schema.items !== 'undefined' || typeof schema.additionalItems !== 'undefined' || typeof schema.contains !== 'undefined';\n}\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\n\n\nfunction likeObject(schema) {\n  return schema.type === 'object' || typeof schema.minProperties !== 'undefined' || typeof schema.maxProperties !== 'undefined' || typeof schema.required !== 'undefined' || typeof schema.properties !== 'undefined' || typeof schema.patternProperties !== 'undefined' || typeof schema.additionalProperties !== 'undefined' || typeof schema.dependencies !== 'undefined' || typeof schema.propertyNames !== 'undefined' || typeof schema.patternRequired !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNull(schema) {\n  return schema.type === 'null';\n}\n/**\n * @param {string} type\n * @returns {string}\n */\n\n\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return 'an';\n  }\n\n  return 'a';\n}\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\n\n\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return '';\n  }\n\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return ' | should be any non-number';\n    }\n\n    if (likeString(schema)) {\n      return ' | should be any non-string';\n    }\n\n    if (likeArray(schema)) {\n      return ' | should be any non-array';\n    }\n\n    if (likeObject(schema)) {\n      return ' | should be any non-object';\n    }\n  }\n\n  return '';\n}\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\n\n\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(', ')})` : '';\n}\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\n\n\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n\n  return [];\n}\n\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n    /** @type {string} */\n\n    this.name = 'ValidationError';\n    /** @type {Array<SchemaUtilErrorObject>} */\n\n    this.errors = errors;\n    /** @type {Schema} */\n\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n    /** @type {string} */\n\n\n    this.headerName = configuration.name || headerNameFromSchema || 'Object';\n    /** @type {string} */\n\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || 'configuration';\n    /** @type {PostFormatter | null} */\n\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n    /** @type {string} */\n\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n\n\n  getSchemaPart(path) {\n    const newPath = path.split('/');\n    let schemaPart = this.schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[\n      /** @type {keyof Schema} */\n      newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  }\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n\n\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n\n      if (prevSchemas.includes(innerSchema)) {\n        return '(recursive)';\n      }\n\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? '' : 'non ';\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n\n    if (\n    /** @type {Schema & {instanceof: string | Array<string>}} */\n    schema.instanceof) {\n      const {\n        instanceof: value\n      } =\n      /** @type {Schema & {instanceof: string | Array<string>}} */\n      schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === 'Function' ? 'function' : item).join(' | ');\n    }\n\n    if (schema.enum) {\n      return (\n        /** @type {Array<any>} */\n        schema.enum.map(item => JSON.stringify(item)).join(' | ')\n      );\n    }\n\n    if (typeof schema.const !== 'undefined') {\n      return JSON.stringify(schema.const);\n    }\n\n    if (schema.oneOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.oneOf.map(item => formatInnerSchema(item, true)).join(' | ')\n      );\n    }\n\n    if (schema.anyOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.anyOf.map(item => formatInnerSchema(item, true)).join(' | ')\n      );\n    }\n\n    if (schema.allOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.allOf.map(item => formatInnerSchema(item, true)).join(' & ')\n      );\n    }\n\n    if (\n    /** @type {JSONSchema7} */\n    schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } =\n      /** @type {JSONSchema7} */\n      schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : ''}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : ''}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : ''}`;\n    }\n\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n      return logic ? str : str === 'string' ? 'non-string' : `non-string | ${str}`;\n    }\n\n    if (likeBoolean(schema)) {\n      return `${logic ? '' : 'non-'}boolean`;\n    }\n\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minItems === 'number') {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? 's' : ''}`);\n      }\n\n      if (typeof schema.maxItems === 'number') {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? 's' : ''}`);\n      }\n\n      if (schema.uniqueItems) {\n        hints.push('should not have duplicate items');\n      }\n\n      const hasAdditionalItems = typeof schema.additionalItems === 'undefined' || Boolean(schema.additionalItems);\n      let items = '';\n\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */\n          schema.items.map(item => formatInnerSchema(item)).join(', ')}`;\n\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = 'any';\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = 'any';\n      }\n\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n\n      return `[${items}${hasAdditionalItems ? ', ...' : ''}]${hints.length > 0 ? ` (${hints.join(', ')})` : ''}`;\n    }\n\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minProperties === 'number') {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? 'properties' : 'property'}`);\n      }\n\n      if (typeof schema.maxProperties === 'number') {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? 'properties' : 'property'}`);\n      }\n\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? 's' : ''} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(' | ')}`);\n      }\n\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set(\n      /** @type {Array<string>} */\n      [].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property); // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n\n        return `${property}${isRequired ? '' : '?'}`;\n      }).concat(typeof schema.additionalProperties === 'undefined' || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : ['…'] : []).join(', ');\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } =\n      /** @type {Schema & {patternRequired?: Array<string>;}} */\n      schema;\n\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? 'properties' : 'property'} ${dependency.map(dep => `'${dep}'`).join(', ')} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n\n      return `object {${objectStructure ? ` ${objectStructure} ` : ''}}${hints.length > 0 ? ` (${hints.join(', ')})` : ''}`;\n    }\n\n    if (likeNull(schema)) {\n      return `${logic ? '' : 'non-'}null`;\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(' | ')}`;\n    } // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n\n    /* istanbul ignore next */\n\n\n    return JSON.stringify(schema, null, 2);\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n\n\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return '';\n    }\n\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[\n        /** @type {keyof Schema} */\n        additionalPath[i]];\n\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? '.' : ''}`;\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n\n\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return '';\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    if (schemaPart.description) {\n      return `\\n-> ${schemaPart.description}`;\n    }\n\n    return '';\n  }\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n\n\n  formatValidationError(error) {\n    const {\n      keyword,\n      dataPath: errorDataPath\n    } = error;\n    const dataPath = `${this.baseDataPath}${errorDataPath}`;\n\n    switch (keyword) {\n      case 'type':\n        {\n          const {\n            parentSchema,\n            params\n          } = error; // eslint-disable-next-line default-case\n\n          switch (\n          /** @type {import(\"ajv\").TypeParams} */\n          params.type) {\n            case 'number':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'integer':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'string':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'boolean':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'array':\n              return `${dataPath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case 'object':\n              return `${dataPath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case 'null':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            default:\n              return `${dataPath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n\n      case 'instanceof':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case 'pattern':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } =\n          /** @type {import(\"ajv\").PatternParams} */\n          params;\n          return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'format':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } =\n          /** @type {import(\"ajv\").FormatParams} */\n          params;\n          return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'formatMinimum':\n      case 'formatMaximum':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minimum':\n      case 'maximum':\n      case 'exclusiveMinimum':\n      case 'exclusiveMaximum':\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          const [, ...hints] = getHints(\n          /** @type {Schema} */\n          parentSchema, true);\n\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n\n          return `${dataPath} ${hints.join(' ')}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'multipleOf':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } =\n          /** @type {import(\"ajv\").MultipleOfParams} */\n          params;\n          return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'patternRequired':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } =\n          /** @type {import(\"ajv\").PatternRequiredParams} */\n          params;\n          return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minLength':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          const length = limit - 1;\n          return `${dataPath} should be longer than ${length} character${length > 1 ? 's' : ''}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxLength':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          const max = limit + 1;\n          return `${dataPath} should be shorter than ${max} character${max > 1 ? 's' : ''}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'uniqueItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } =\n          /** @type {import(\"ajv\").UniqueItemsParams} */\n          params;\n          return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'additionalItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'contains':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, ['contains'])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n\n      case 'required':\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params.missingProperty.replace(/^\\./, '');\n          const hasProperty = parentSchema && Boolean(\n          /** @type {Schema} */\n          parentSchema.properties &&\n          /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, ['properties', missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'additionalProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } =\n          /** @type {import(\"ajv\").AdditionalPropertiesParams} */\n          params;\n          return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'dependencies':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params;\n          const dependencies = deps.split(',').map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(', ');\n          return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'propertyNames':\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } =\n          /** @type {import(\"ajv\").PropertyNamesParams} */\n          params;\n          return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'enum':\n        {\n          const {\n            parentSchema\n          } = error;\n\n          if (parentSchema &&\n          /** @type {Schema} */\n          parentSchema.enum &&\n          /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${dataPath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'const':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case 'not':\n        {\n          const postfix = likeObject(\n          /** @type {Schema} */\n          error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : '';\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n\n          if (canApplyNot(error.schema)) {\n            return `${dataPath} should be any ${schemaOutput}${postfix}.`;\n          }\n\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${dataPath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : ''}`;\n        }\n\n      case 'oneOf':\n      case 'anyOf':\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n\n            let filteredChildren = filterChildren(children);\n\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), '   ')}`).join('\\n')}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'if':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } =\n          /** @type {import(\"ajv\").IfParams} */\n          params;\n          return `${dataPath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n\n      case 'absolutePath':\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n\n          return `${dataPath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n\n\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n\n      return ` - ${indent(formattedError, '   ')}`;\n    }).join('\\n');\n  }\n\n}\n\nvar _default = ValidationError;\nexports.default = _default;"]}