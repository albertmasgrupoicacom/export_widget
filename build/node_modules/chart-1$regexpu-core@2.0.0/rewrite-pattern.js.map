{"version":3,"sources":["rewrite-pattern.js"],"names":["generate","require","parse","regenerate","iuMappings","ESCAPE_SETS","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","UNICODE","REGULAR","object","hasOwnProperty","has","property","call","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","DOT_SET","intersection","prototype","iuAddRange","min","max","$this","folded","caseFold","add","assign","target","source","key","update","item","pattern","tree","type","wrap","codePoint","processCharacterClass","characterClassItem","set","body","forEach","value","Error","negative","toString","processTerm","map","module","exports","flags","indexOf"],"mappings":"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","file":"rewrite-pattern.js","sourcesContent":["var generate = require('regjsgen').generate;\nvar parse = require('regjsparser').parse;\nvar regenerate = require('regenerate');\nvar iuMappings = require('./data/iu-mappings.json');\nvar ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\nfunction getCharacterClassEscapeSet(character) {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE[character];\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE[character];\n\t}\n\treturn ESCAPE_SETS.REGULAR[character];\n}\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nfunction has(object, property) {\n\treturn hasOwnProperty.call(object, property);\n}\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nvar UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nvar BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nvar DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./` (only BMP code points).\nvar DOT_SET = DOT_SET_UNICODE.clone()\n\t.intersection(BMP_SET);\n\n// Add a range of code points + any case-folded code points in that range to a\n// set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tvar $this = this;\n\tdo {\n\t\tvar folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nfunction assign(target, source) {\n\tfor (var key in source) {\n\t\t// Note: `hasOwnProperty` is not needed here.\n\t\ttarget[key] = source[key];\n\t}\n}\n\nfunction update(item, pattern) {\n\t// TODO: Test if memoizing `pattern` here is worth the effort.\n\tif (!pattern) {\n\t\treturn;\n\t}\n\tvar tree = parse(pattern, '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tassign(item, tree);\n}\n\nfunction wrap(tree, pattern) {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': '(?:' + pattern + ')'\n\t};\n}\n\nfunction caseFold(codePoint) {\n\treturn has(iuMappings, codePoint) ? iuMappings[codePoint] : false;\n}\n\nvar ignoreCase = false;\nvar unicode = false;\nfunction processCharacterClass(characterClassItem) {\n\tvar set = regenerate();\n\tvar body = characterClassItem.body.forEach(function(item) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (ignoreCase && unicode) {\n\t\t\t\t\tvar folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tvar min = item.min.codePoint;\n\t\t\t\tvar max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (ignoreCase && unicode) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(item.value));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow Error('Unknown term type: ' + item.type);\n\t\t}\n\t});\n\tif (characterClassItem.negative) {\n\t\tset = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n\t}\n\tupdate(characterClassItem, set.toString());\n\treturn characterClassItem;\n}\n\nfunction processTerm(item) {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\t(unicode ? DOT_SET_UNICODE : DOT_SET).toString()\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item);\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(item.value).toString()\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'group':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(processTerm);\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tvar codePoint = item.codePoint;\n\t\t\tvar set = regenerate(codePoint);\n\t\t\tif (ignoreCase && unicode) {\n\t\t\t\tvar folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString());\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\tcase 'reference':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow Error('Unknown term type: ' + item.type);\n\t}\n\treturn item;\n};\n\nmodule.exports = function(pattern, flags) {\n\tvar tree = parse(pattern, flags);\n\tignoreCase = flags ? flags.indexOf('i') > -1 : false;\n\tunicode = flags ? flags.indexOf('u') > -1 : false;\n\tassign(tree, processTerm(tree));\n\treturn generate(tree);\n};\n"]}