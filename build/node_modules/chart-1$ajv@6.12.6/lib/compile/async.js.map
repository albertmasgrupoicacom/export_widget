{"version":3,"sources":["async.js"],"names":["MissingRefError","require","MissingRef","module","exports","compileAsync","schema","meta","callback","self","_opts","loadSchema","Error","undefined","p","loadMetaSchemaOf","then","schemaObj","_addSchema","validate","_compileAsync","v","sch","$schema","getSchema","call","$ref","Promise","resolve","_compile","e","loadMissingSchema","ref","missingSchema","added","missingRef","schemaPromise","_loadingSchemas","removePromise","addSchema","_refs","_schemas"],"mappings":"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","file":"async.js","sourcesContent":["'use strict';\n\nvar MissingRefError = require('./error_classes').MissingRef;\n\nmodule.exports = compileAsync;\n\n\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n  /* global Promise */\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function')\n    throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(\n      function(v) { callback(null, v); },\n      callback\n    );\n  }\n\n  return p;\n\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema)\n            ? compileAsync.call(self, { $ref: $schema }, true)\n            : Promise.resolve();\n  }\n\n\n  function _compileAsync(schemaObj) {\n    try { return self._compile(schemaObj); }\n    catch(e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n\n      var schemaPromise = self._loadingSchemas[ref];\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function() {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}\n"]}