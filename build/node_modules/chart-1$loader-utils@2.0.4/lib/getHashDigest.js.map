{"version":3,"sources":["getHashDigest.js"],"names":["baseEncodeTables","encodeBufferToBase","buffer","base","encodeTable","Error","readLength","length","Big","require","RM","DP","b","i","times","plus","output","gt","mod","div","createMd4","undefined","BatchedHash","getHashDigest","hashType","digestType","maxLength","hash","createHash","error","code","update","digest","substr","module","exports"],"mappings":"AAAA;;;;;;AAEA,UAAMA,mBAAmB;AACvB,UAAI,4BADmB;AAEvB,UAAI,kCAFmB,EAEiB;AACxC,UAAI,sCAHmB;AAIvB,UAAI,mDAJmB,EAIkC;AACzD,UAAI,sDALmB;AAMvB,UAAI,4DANmB,EAM2C;AAClE,UAAI,gEAPmB;AAQvB,UAAI;AARmB,KAAzB;;AAWA,aAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;AACxC,YAAMC,cAAcJ,iBAAiBG,IAAjB,CAApB;AACA,UAAI,CAACC,WAAL,EAAkB;AAChB,cAAM,IAAIC,KAAJ,CAAU,0BAA0BF,IAApC,CAAN;AACD;;AAED,YAAMG,aAAaJ,OAAOK,MAA1B;AACA,YAAMC,MAAMC,QAAQ,gBAAR,CAAZ;;AAEAD,UAAIE,EAAJ,GAASF,IAAIG,EAAJ,GAAS,CAAlB;AACA,UAAIC,IAAI,IAAIJ,GAAJ,CAAQ,CAAR,CAAR;;AAEA,WAAK,IAAIK,IAAIP,aAAa,CAA1B,EAA6BO,KAAK,CAAlC,EAAqCA,GAArC,EAA0C;AACxCD,YAAIA,EAAEE,KAAF,CAAQ,GAAR,EAAaC,IAAb,CAAkBb,OAAOW,CAAP,CAAlB,CAAJ;AACD;;AAED,UAAIG,SAAS,EAAb;AACA,aAAOJ,EAAEK,EAAF,CAAK,CAAL,CAAP,EAAgB;AACdD,iBAASZ,YAAYQ,EAAEM,GAAF,CAAMf,IAAN,CAAZ,IAA2Ba,MAApC;AACAJ,YAAIA,EAAEO,GAAF,CAAMhB,IAAN,CAAJ;AACD;;AAEDK,UAAIG,EAAJ,GAAS,EAAT;AACAH,UAAIE,EAAJ,GAAS,CAAT;;AAEA,aAAOM,MAAP;AACD;;AAED,QAAII,YAAYC,SAAhB;AACA,QAAIC,cAAcD,SAAlB;;AAEA,aAASE,aAAT,CAAuBrB,MAAvB,EAA+BsB,QAA/B,EAAyCC,UAAzC,EAAqDC,SAArD,EAAgE;AAC9DF,iBAAWA,YAAY,KAAvB;AACAE,kBAAYA,aAAa,IAAzB;;AAEA,UAAIC,IAAJ;;AAEA,UAAI;AACFA,eAAOlB,QAAQ,gBAAR,EAAkBmB,UAAlB,CAA6BJ,QAA7B,CAAP;AACD,OAFD,CAEE,OAAOK,KAAP,EAAc;AACd,YAAIA,MAAMC,IAAN,KAAe,0BAAf,IAA6CN,aAAa,KAA9D,EAAqE;AACnE,cAAIJ,cAAcC,SAAlB,EAA6B;AAC3BD,wBAAYX,QAAQ,YAAR,CAAZ;;AAEA,gBAAIa,gBAAgBD,SAApB,EAA+B;AAC7BC,4BAAcb,QAAQ,oBAAR,CAAd;AACD;AACF;;AAEDkB,iBAAO,IAAIL,WAAJ,CAAgBF,WAAhB,CAAP;AACD;;AAED,YAAI,CAACO,IAAL,EAAW;AACT,gBAAME,KAAN;AACD;AACF;;AAEDF,WAAKI,MAAL,CAAY7B,MAAZ;;AAEA,UACEuB,eAAe,QAAf,IACAA,eAAe,QADf,IAEAA,eAAe,QAFf,IAGAA,eAAe,QAHf,IAIAA,eAAe,QAJf,IAKAA,eAAe,QALf,IAMAA,eAAe,QAPjB,EAQE;AACA,eAAOxB,mBAAmB0B,KAAKK,MAAL,EAAnB,EAAkCP,WAAWQ,MAAX,CAAkB,CAAlB,CAAlC,EAAwDA,MAAxD,CACL,CADK,EAELP,SAFK,CAAP;AAID,OAbD,MAaO;AACL,eAAOC,KAAKK,MAAL,CAAYP,cAAc,KAA1B,EAAiCQ,MAAjC,CAAwC,CAAxC,EAA2CP,SAA3C,CAAP;AACD;AACF;;AAEDQ,WAAOC,OAAP,GAAiBZ,aAAjB","file":"getHashDigest.js","sourcesContent":["'use strict';\n\nconst baseEncodeTables = {\n  26: 'abcdefghijklmnopqrstuvwxyz',\n  32: '123456789abcdefghjkmnpqrstuvwxyz', // no 0lio\n  36: '0123456789abcdefghijklmnopqrstuvwxyz',\n  49: 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ', // no lIO\n  52: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  58: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ', // no 0lIO\n  62: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  64: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_',\n};\n\nfunction encodeBufferToBase(buffer, base) {\n  const encodeTable = baseEncodeTables[base];\n  if (!encodeTable) {\n    throw new Error('Unknown encoding base' + base);\n  }\n\n  const readLength = buffer.length;\n  const Big = require('big.js');\n\n  Big.RM = Big.DP = 0;\n  let b = new Big(0);\n\n  for (let i = readLength - 1; i >= 0; i--) {\n    b = b.times(256).plus(buffer[i]);\n  }\n\n  let output = '';\n  while (b.gt(0)) {\n    output = encodeTable[b.mod(base)] + output;\n    b = b.div(base);\n  }\n\n  Big.DP = 20;\n  Big.RM = 1;\n\n  return output;\n}\n\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\nfunction getHashDigest(buffer, hashType, digestType, maxLength) {\n  hashType = hashType || 'md4';\n  maxLength = maxLength || 9999;\n\n  let hash;\n\n  try {\n    hash = require('crypto').createHash(hashType);\n  } catch (error) {\n    if (error.code === 'ERR_OSSL_EVP_UNSUPPORTED' && hashType === 'md4') {\n      if (createMd4 === undefined) {\n        createMd4 = require('./hash/md4');\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require('./hash/BatchedHash');\n        }\n      }\n\n      hash = new BatchedHash(createMd4());\n    }\n\n    if (!hash) {\n      throw error;\n    }\n  }\n\n  hash.update(buffer);\n\n  if (\n    digestType === 'base26' ||\n    digestType === 'base32' ||\n    digestType === 'base36' ||\n    digestType === 'base49' ||\n    digestType === 'base52' ||\n    digestType === 'base58' ||\n    digestType === 'base62'\n  ) {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(\n      0,\n      maxLength\n    );\n  } else {\n    return hash.digest(digestType || 'hex').substr(0, maxLength);\n  }\n}\n\nmodule.exports = getHashDigest;\n"]}