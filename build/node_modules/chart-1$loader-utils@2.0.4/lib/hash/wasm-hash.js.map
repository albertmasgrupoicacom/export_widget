{"version":3,"sources":["wasm-hash.js"],"names":["MAX_SHORT_STRING","Math","floor","WasmHash","constructor","instance","instancesPool","chunkSize","digestSize","exports","init","mem","Buffer","from","memory","buffer","buffered","reset","update","data","encoding","length","_updateWithShortString","slice","_updateWithBuffer","endPos","i","cc","charCodeAt","write","l","newBuffered","copyWithin","copy","digest","type","final","push","hex","toString","create","wasmModule","old","pop","WebAssembly","Instance","module"],"mappings":"AAAA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;;;;;AACA,UAAMA,mBAAmBC,KAAKC,KAAL,CAAW,CAAC,QAAQ,EAAT,IAAe,CAA1B,IAA+B,CAAC,CAAzD;;AAEA,UAAMC,QAAN,CAAe;AACb;;;;;;AAMAC,kBAAYC,QAAZ,EAAsBC,aAAtB,EAAqCC,SAArC,EAAgDC,UAAhD,EAA4D;AAC1D,cAAMC,UAAU,kBAAoBJ,SAASI,OAA7C;;AAEAA,gBAAQC,IAAR;;AAEA,aAAKD,OAAL,GAAeA,OAAf;AACA,aAAKE,GAAL,GAAWC,OAAOC,IAAP,CAAYJ,QAAQK,MAAR,CAAeC,MAA3B,EAAmC,CAAnC,EAAsC,KAAtC,CAAX;AACA,aAAKC,QAAL,GAAgB,CAAhB;AACA,aAAKV,aAAL,GAAqBA,aAArB;AACA,aAAKC,SAAL,GAAiBA,SAAjB;AACA,aAAKC,UAAL,GAAkBA,UAAlB;AACD;;AAEDS,cAAQ;AACN,aAAKD,QAAL,GAAgB,CAAhB;AACA,aAAKP,OAAL,CAAaC,IAAb;AACD;;AAED;;;;;AAKAQ,aAAOC,IAAP,EAAaC,QAAb,EAAuB;AACrB,YAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC5B,iBAAOA,KAAKE,MAAL,GAAcrB,gBAArB,EAAuC;AACrC,iBAAKsB,sBAAL,CAA4BH,KAAKI,KAAL,CAAW,CAAX,EAAcvB,gBAAd,CAA5B,EAA6DoB,QAA7D;AACAD,mBAAOA,KAAKI,KAAL,CAAWvB,gBAAX,CAAP;AACD;;AAED,eAAKsB,sBAAL,CAA4BH,IAA5B,EAAkCC,QAAlC;;AAEA,iBAAO,IAAP;AACD;;AAED,aAAKI,iBAAL,CAAuBL,IAAvB;;AAEA,eAAO,IAAP;AACD;;AAED;;;;;AAKAG,6BAAuBH,IAAvB,EAA6BC,QAA7B,EAAuC;AACrC,cAAM,EAAEX,OAAF,EAAWO,QAAX,EAAqBL,GAArB,EAA0BJ,SAA1B,KAAwC,IAA9C;;AAEA,YAAIkB,MAAJ;;AAEA,YAAIN,KAAKE,MAAL,GAAc,EAAlB,EAAsB;AACpB,cAAI,CAACD,QAAD,IAAaA,aAAa,OAA1B,IAAqCA,aAAa,MAAtD,EAA8D;AAC5DK,qBAAST,QAAT;AACA,iBAAK,IAAIU,IAAI,CAAb,EAAgBA,IAAIP,KAAKE,MAAzB,EAAiCK,GAAjC,EAAsC;AACpC,oBAAMC,KAAKR,KAAKS,UAAL,CAAgBF,CAAhB,CAAX;;AAEA,kBAAIC,KAAK,IAAT,EAAe;AACbhB,oBAAIc,QAAJ,IAAgBE,EAAhB;AACD,eAFD,MAEO,IAAIA,KAAK,KAAT,EAAgB;AACrBhB,oBAAIc,MAAJ,IAAeE,MAAM,CAAP,GAAY,IAA1B;AACAhB,oBAAIc,SAAS,CAAb,IAAmBE,KAAK,IAAN,GAAc,IAAhC;AACAF,0BAAU,CAAV;AACD,eAJM,MAIA;AACL;AACAA,0BAAUd,IAAIkB,KAAJ,CAAUV,KAAKI,KAAL,CAAWG,CAAX,CAAV,EAAyBD,MAAzB,EAAiCL,QAAjC,CAAV;AACA;AACD;AACF;AACF,WAjBD,MAiBO,IAAIA,aAAa,QAAjB,EAA2B;AAChCK,qBAAST,QAAT;;AAEA,iBAAK,IAAIU,IAAI,CAAb,EAAgBA,IAAIP,KAAKE,MAAzB,EAAiCK,GAAjC,EAAsC;AACpC,oBAAMC,KAAKR,KAAKS,UAAL,CAAgBF,CAAhB,CAAX;;AAEAf,kBAAIc,QAAJ,IAAgBE,EAAhB;AACD;AACF,WARM,MAQA;AACLF,qBAAST,WAAWL,IAAIkB,KAAJ,CAAUV,IAAV,EAAgBH,QAAhB,EAA0BI,QAA1B,CAApB;AACD;AACF,SA7BD,MA6BO;AACLK,mBAAST,WAAWL,IAAIkB,KAAJ,CAAUV,IAAV,EAAgBH,QAAhB,EAA0BI,QAA1B,CAApB;AACD;;AAED,YAAIK,SAASlB,SAAb,EAAwB;AACtB,eAAKS,QAAL,GAAgBS,MAAhB;AACD,SAFD,MAEO;AACL,gBAAMK,IAAIL,SAAS,EAAE,KAAKlB,SAAL,GAAiB,CAAnB,CAAnB;;AAEAE,kBAAQS,MAAR,CAAeY,CAAf;;AAEA,gBAAMC,cAAcN,SAASK,CAA7B;;AAEA,eAAKd,QAAL,GAAgBe,WAAhB;;AAEA,cAAIA,cAAc,CAAlB,EAAqB;AACnBpB,gBAAIqB,UAAJ,CAAe,CAAf,EAAkBF,CAAlB,EAAqBL,MAArB;AACD;AACF;AACF;;AAED;;;;AAIAD,wBAAkBL,IAAlB,EAAwB;AACtB,cAAM,EAAEV,OAAF,EAAWO,QAAX,EAAqBL,GAArB,KAA6B,IAAnC;AACA,cAAMU,SAASF,KAAKE,MAApB;;AAEA,YAAIL,WAAWK,MAAX,GAAoB,KAAKd,SAA7B,EAAwC;AACtCY,eAAKc,IAAL,CAAUtB,GAAV,EAAeK,QAAf,EAAyB,CAAzB,EAA4BK,MAA5B;;AAEA,eAAKL,QAAL,IAAiBK,MAAjB;AACD,SAJD,MAIO;AACL,gBAAMS,IAAKd,WAAWK,MAAZ,GAAsB,EAAE,KAAKd,SAAL,GAAiB,CAAnB,CAAhC;;AAEA,cAAIuB,IAAI,KAAR,EAAe;AACb,gBAAIJ,IAAI,QAAQV,QAAhB;;AAEAG,iBAAKc,IAAL,CAAUtB,GAAV,EAAeK,QAAf,EAAyB,CAAzB,EAA4BU,CAA5B;AACAjB,oBAAQS,MAAR,CAAe,KAAf;;AAIA,mBAAOQ,IAFMI,IAAId,QAAJ,GAAe,KAE5B,EAAiB;AACfG,mBAAKc,IAAL,CAAUtB,GAAV,EAAe,CAAf,EAAkBe,CAAlB,EAAqBA,IAAI,KAAzB;AACAjB,sBAAQS,MAAR,CAAe,KAAf;AACAQ,mBAAK,KAAL;AACD;;AAEDP,iBAAKc,IAAL,CAAUtB,GAAV,EAAe,CAAf,EAAkBe,CAAlB,EAAqBI,IAAId,QAAzB;;AAEAP,oBAAQS,MAAR,CAAeY,IAAId,QAAJ,GAAeU,CAA9B;AACD,WAjBD,MAiBO;AACLP,iBAAKc,IAAL,CAAUtB,GAAV,EAAeK,QAAf,EAAyB,CAAzB,EAA4Bc,IAAId,QAAhC;;AAEAP,oBAAQS,MAAR,CAAeY,CAAf;AACD;;AAED,gBAAMC,cAAcV,SAASL,QAAT,GAAoBc,CAAxC;;AAEA,eAAKd,QAAL,GAAgBe,WAAhB;;AAEA,cAAIA,cAAc,CAAlB,EAAqB;AACnBZ,iBAAKc,IAAL,CAAUtB,GAAV,EAAe,CAAf,EAAkBU,SAASU,WAA3B,EAAwCV,MAAxC;AACD;AACF;AACF;;AAEDa,aAAOC,IAAP,EAAa;AACX,cAAM,EAAE1B,OAAF,EAAWO,QAAX,EAAqBL,GAArB,EAA0BH,UAA1B,KAAyC,IAA/C;;AAEAC,gBAAQ2B,KAAR,CAAcpB,QAAd;;AAEA,aAAKV,aAAL,CAAmB+B,IAAnB,CAAwB,IAAxB;;AAEA,cAAMC,MAAM3B,IAAI4B,QAAJ,CAAa,QAAb,EAAuB,CAAvB,EAA0B/B,UAA1B,CAAZ;;AAEA,YAAI2B,SAAS,KAAb,EAAoB;AAClB,iBAAOG,GAAP;AACD;;AAED,YAAIH,SAAS,QAAT,IAAqB,CAACA,IAA1B,EAAgC;AAC9B,iBAAOvB,OAAOC,IAAP,CAAYyB,GAAZ,EAAiB,KAAjB,CAAP;AACD;;AAED,eAAO1B,OAAOC,IAAP,CAAYyB,GAAZ,EAAiB,KAAjB,EAAwBC,QAAxB,CAAiCJ,IAAjC,CAAP;AACD;AA7KY;;AAgLf,UAAMK,SAAS,CAACC,UAAD,EAAanC,aAAb,EAA4BC,SAA5B,EAAuCC,UAAvC,KAAsD;AACnE,UAAIF,cAAce,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,cAAMqB,MAAMpC,cAAcqC,GAAd,EAAZ;;AAEAD,YAAIzB,KAAJ;;AAEA,eAAOyB,GAAP;AACD,OAND,MAMO;AACL,eAAO,IAAIvC,QAAJ,CACL,IAAIyC,YAAYC,QAAhB,CAAyBJ,UAAzB,CADK,EAELnC,aAFK,EAGLC,SAHK,EAILC,UAJK,CAAP;AAMD;AACF,KAfD;;AAiBAsC,WAAOrC,OAAP,GAAiB+B,MAAjB;AACAM,WAAOrC,OAAP,CAAeT,gBAAf,GAAkCA,gBAAlC","file":"wasm-hash.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n'use strict';\n\n// 65536 is the size of a wasm memory page\n// 64 is the maximum chunk size for every possible wasm hash implementation\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\nconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\n\nclass WasmHash {\n  /**\n   * @param {WebAssembly.Instance} instance wasm instance\n   * @param {WebAssembly.Instance[]} instancesPool pool of instances\n   * @param {number} chunkSize size of data chunks passed to wasm\n   * @param {number} digestSize size of digest returned by wasm\n   */\n  constructor(instance, instancesPool, chunkSize, digestSize) {\n    const exports = /** @type {any} */ (instance.exports);\n\n    exports.init();\n\n    this.exports = exports;\n    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n    this.buffered = 0;\n    this.instancesPool = instancesPool;\n    this.chunkSize = chunkSize;\n    this.digestSize = digestSize;\n  }\n\n  reset() {\n    this.buffered = 0;\n    this.exports.init();\n  }\n\n  /**\n   * @param {Buffer | string} data data\n   * @param {BufferEncoding=} encoding encoding\n   * @returns {this} itself\n   */\n  update(data, encoding) {\n    if (typeof data === 'string') {\n      while (data.length > MAX_SHORT_STRING) {\n        this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n        data = data.slice(MAX_SHORT_STRING);\n      }\n\n      this._updateWithShortString(data, encoding);\n\n      return this;\n    }\n\n    this._updateWithBuffer(data);\n\n    return this;\n  }\n\n  /**\n   * @param {string} data data\n   * @param {BufferEncoding=} encoding encoding\n   * @returns {void}\n   */\n  _updateWithShortString(data, encoding) {\n    const { exports, buffered, mem, chunkSize } = this;\n\n    let endPos;\n\n    if (data.length < 70) {\n      if (!encoding || encoding === 'utf-8' || encoding === 'utf8') {\n        endPos = buffered;\n        for (let i = 0; i < data.length; i++) {\n          const cc = data.charCodeAt(i);\n\n          if (cc < 0x80) {\n            mem[endPos++] = cc;\n          } else if (cc < 0x800) {\n            mem[endPos] = (cc >> 6) | 0xc0;\n            mem[endPos + 1] = (cc & 0x3f) | 0x80;\n            endPos += 2;\n          } else {\n            // bail-out for weird chars\n            endPos += mem.write(data.slice(i), endPos, encoding);\n            break;\n          }\n        }\n      } else if (encoding === 'latin1') {\n        endPos = buffered;\n\n        for (let i = 0; i < data.length; i++) {\n          const cc = data.charCodeAt(i);\n\n          mem[endPos++] = cc;\n        }\n      } else {\n        endPos = buffered + mem.write(data, buffered, encoding);\n      }\n    } else {\n      endPos = buffered + mem.write(data, buffered, encoding);\n    }\n\n    if (endPos < chunkSize) {\n      this.buffered = endPos;\n    } else {\n      const l = endPos & ~(this.chunkSize - 1);\n\n      exports.update(l);\n\n      const newBuffered = endPos - l;\n\n      this.buffered = newBuffered;\n\n      if (newBuffered > 0) {\n        mem.copyWithin(0, l, endPos);\n      }\n    }\n  }\n\n  /**\n   * @param {Buffer} data data\n   * @returns {void}\n   */\n  _updateWithBuffer(data) {\n    const { exports, buffered, mem } = this;\n    const length = data.length;\n\n    if (buffered + length < this.chunkSize) {\n      data.copy(mem, buffered, 0, length);\n\n      this.buffered += length;\n    } else {\n      const l = (buffered + length) & ~(this.chunkSize - 1);\n\n      if (l > 65536) {\n        let i = 65536 - buffered;\n\n        data.copy(mem, buffered, 0, i);\n        exports.update(65536);\n\n        const stop = l - buffered - 65536;\n\n        while (i < stop) {\n          data.copy(mem, 0, i, i + 65536);\n          exports.update(65536);\n          i += 65536;\n        }\n\n        data.copy(mem, 0, i, l - buffered);\n\n        exports.update(l - buffered - i);\n      } else {\n        data.copy(mem, buffered, 0, l - buffered);\n\n        exports.update(l);\n      }\n\n      const newBuffered = length + buffered - l;\n\n      this.buffered = newBuffered;\n\n      if (newBuffered > 0) {\n        data.copy(mem, 0, length - newBuffered, length);\n      }\n    }\n  }\n\n  digest(type) {\n    const { exports, buffered, mem, digestSize } = this;\n\n    exports.final(buffered);\n\n    this.instancesPool.push(this);\n\n    const hex = mem.toString('latin1', 0, digestSize);\n\n    if (type === 'hex') {\n      return hex;\n    }\n\n    if (type === 'binary' || !type) {\n      return Buffer.from(hex, 'hex');\n    }\n\n    return Buffer.from(hex, 'hex').toString(type);\n  }\n}\n\nconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\n  if (instancesPool.length > 0) {\n    const old = instancesPool.pop();\n\n    old.reset();\n\n    return old;\n  } else {\n    return new WasmHash(\n      new WebAssembly.Instance(wasmModule),\n      instancesPool,\n      chunkSize,\n      digestSize\n    );\n  }\n};\n\nmodule.exports = create;\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;\n"]}