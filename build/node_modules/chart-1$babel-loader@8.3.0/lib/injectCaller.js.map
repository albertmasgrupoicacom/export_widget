{"version":3,"sources":["injectCaller.js"],"names":["babel","require","module","exports","injectCaller","opts","target","supportsCallerOption","Object","assign","caller","name","supportsStaticESM","supportsDynamicImport","supportsTopLevelAwait","supportsCallerOptionFlag","undefined","loadPartialConfig","babelrc","configFile","err"],"mappings":"AAAA;;;;;;AAEA,UAAMA,QAAQC,QAAQ,qBAAR,CAAd;AACAC,WAAOC,OAAP,GAAiB,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,MAA5B,EAAoC;AACnD,UAAI,CAACC,sBAAL,EAA6B,OAAOF,IAAP;AAC7B,aAAOG,OAAOC,MAAP,CAAc,EAAd,EAAkBJ,IAAlB,EAAwB;AAC7BK,gBAAQF,OAAOC,MAAP,CAAc;AACpBE,gBAAM,cADc;AAEpB;AACA;AACAL,gBAJoB;AAKpB;AACAM,6BAAmB,IANC;AAOpBC,iCAAuB,IAPH;AAQpB;AACA;AACA;AACAC,iCAAuB;AAXH,SAAd,EAYLT,KAAKK,MAZA;AADqB,OAAxB,CAAP;AAeD,KAjBD;;AAmBA;AACA;AACA;AACA,QAAIK,2BAA2BC,SAA/B;AACA,aAAST,oBAAT,GAAgC;AAC9B,UAAIQ,6BAA6BC,SAAjC,EAA4C;AAC1C,YAAI;AACF;AACA;AACAhB,gBAAMiB,iBAAN,CAAwB;AACtBP,oBAAQM,SADc;AAEtBE,qBAAS,KAFa;AAGtBC,wBAAY;AAHU,WAAxB;AAKAJ,qCAA2B,IAA3B;AACD,SATD,CASE,OAAOK,GAAP,EAAY;AACZL,qCAA2B,KAA3B;AACD;AACF;AACD,aAAOA,wBAAP;AACD","file":"injectCaller.js","sourcesContent":["\"use strict\";\n\nconst babel = require(\"@babel/core\");\nmodule.exports = function injectCaller(opts, target) {\n  if (!supportsCallerOption()) return opts;\n  return Object.assign({}, opts, {\n    caller: Object.assign({\n      name: \"babel-loader\",\n      // Provide plugins with insight into webpack target.\n      // https://github.com/babel/babel-loader/issues/787\n      target,\n      // Webpack >= 2 supports ESM and dynamic import.\n      supportsStaticESM: true,\n      supportsDynamicImport: true,\n      // Webpack 5 supports TLA behind a flag. We enable it by default\n      // for Babel, and then webpack will throw an error if the experimental\n      // flag isn't enabled.\n      supportsTopLevelAwait: true\n    }, opts.caller)\n  });\n};\n\n// TODO: We can remove this eventually, I'm just adding it so that people have\n// a little time to migrate to the newer RCs of @babel/core without getting\n// hard-to-diagnose errors about unknown 'caller' options.\nlet supportsCallerOptionFlag = undefined;\nfunction supportsCallerOption() {\n  if (supportsCallerOptionFlag === undefined) {\n    try {\n      // Rather than try to match the Babel version, we just see if it throws\n      // when passed a 'caller' flag, and use that to decide if it is supported.\n      babel.loadPartialConfig({\n        caller: undefined,\n        babelrc: false,\n        configFile: false\n      });\n      supportsCallerOptionFlag = true;\n    } catch (err) {\n      supportsCallerOptionFlag = false;\n    }\n  }\n  return supportsCallerOptionFlag;\n}"]}