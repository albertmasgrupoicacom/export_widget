{"version":3,"sources":["inferer-reference.js"],"names":["exports","__esModule","_getIterator2","require","_getIterator3","_interopRequireDefault","default","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","t","voidTypeAnnotation","numberTypeAnnotation","_babelTypes","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","path","types","unionTypeAnnotation","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","concat","_iterator","_isArray","Array","isArray","_i","_ref","next","done","value","violation","getTypeAnnotation","createUnionTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","BOOLEAN_NUMBER_BINARY_OPERATORS","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","test","paths","_path","shift","isLogicalExpression","isBinaryExpression","type","module"],"mappings":"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","file":"inferer-reference.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (node) {\n  if (!this.isReferenced()) return;\n\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var violation = _ref;\n\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target = void 0;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  var typeofPath = void 0;\n  var typePath = void 0;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = void 0;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]}