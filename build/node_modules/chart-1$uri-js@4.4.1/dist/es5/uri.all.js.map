{"version":3,"sources":["../../src/index.ts","../../src/schemes/urn-uuid.ts","../../src/schemes/urn.ts","../../src/schemes/mailto.ts","../../src/schemes/wss.ts","../../src/schemes/ws.ts","../../src/schemes/https.ts","../../src/schemes/http.ts","../../src/uri.ts","../../node_modules/punycode/punycode.es6.js","../../src/regexps-iri.ts","../../src/regexps-uri.ts","../../src/util.ts"],"names":["SCHEMES","http","https","ws","wss","mailto","urn","uuid","UUID","handler","uuidComponents","options","urnComponents","URN_PARSE","matches","components","scheme","nid","nss","urnScheme","schemeHandler","uriComponents","O","UNRESERVED$$","HEXDIG$$","PCT_ENCODED$","subexp","VCHAR$$","merge","UNRESERVED","PCT_ENCODED","NOT_LOCAL_PART","NOT_HFNAME","decStr","pctDecChars","mailtoComponents","to","unknownHeaders","headers","hfields","x","xl","hfield","toAddrs","unescapeComponent","addr","punycode","toArray","toAddr","String","atIdx","localPart","domain","fields","name","serialize","wsComponents","isSecure","path","secure","c","chr","e","newStr","i","il","str","parseInt","c2","c3","decodeUnreserved","protocol","host","address","firstFields","first","lastFields","last","isLastFieldIPv4Address","fieldCount","lastFieldsStart","Array","_normalizeIPv4","allZeroFields","field","lastLongest","acc","index","length","longestZeroFields","b","a","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","isNaN","_normalizeIPv6","uriTokens","$2","RDS1","RDS2","RDS3","RDS5","output","input","im","s","authority","_recomposeAuthority","removeDotSegments","target","parse","relative","base","schemelessOptions","assign","resolveComponents","typeOf","uriA","URI_PROTOCOL","IRI_PROTOCOL","maxInt","tMin","tMax","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","result","array","fn","parts","string","labels","encoded","map","counter","value","extra","ucs2encode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","k","firstTime","delta","decode","inputLength","n","bias","basic","j","oldi","w","t","baseMinusT","out","encode","ucs2decode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","toASCII","buildExps","ALPHA$$","DIGIT$$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","isIRI","SCHEME$","USERINFO$","DEC_OCTET$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV6ADDRESS1$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","HOST$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH$","QUERY$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_REFERENCE$","ABSOLUTE_URI$","GENERIC_REF$","RELATIVE_REF$","ABSOLUTE_REF$","SAMEDOC_REF$","AUTHORITY_REF$","sets","o","Object","obj","source"],"mappings":"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","sourcesContent":["import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}"]}