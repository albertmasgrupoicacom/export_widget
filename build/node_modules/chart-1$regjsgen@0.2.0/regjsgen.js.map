{"version":3,"sources":["regjsgen.js"],"names":["objectTypes","root","window","freeExports","exports","freeModule","module","nodeType","freeGlobal","global","self","stringFromCharCode","String","fromCharCode","floor","Math","fromCodePoint","codeUnits","highSurrogate","lowSurrogate","index","length","arguments","result","codePoint","Number","isFinite","RangeError","push","apply","assertType","type","expected","indexOf","Error","hasOwnProperty","RegExp","test","generate","node","generateAtom","generateClassAtom","generateTerm","alternative","generateAlternative","terms","body","i","anchor","generateAnchor","kind","characterClass","generateCharacterClass","classRanges","negative","characterClassEscape","generateCharacterClassEscape","value","characterClassRange","generateCharacterClassRange","min","max","disjunction","generateDisjunction","dot","generateDot","group","generateGroup","behavior","behaviour","quantifier","generateQuantifier","undefined","greedy","reference","generateReference","matchIndex","generateValue","toString","toUpperCase","slice","define","amd","regjsgen","call"],"mappings":"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","file":"regjsgen.js","sourcesContent":["/*!\n * RegJSGen\n * Copyright 2014 Benjamin Tan <https://d10.github.io/>\n * Available under MIT license <http://d10.mit-license.org/>\n */\n;(function() {\n  'use strict';\n\n  /** Used to determine if values are of the language type `Object` */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Backup possible global object */\n  var oldRoot = root;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /*! Based on https://mths.be/fromcodepoint v0.2.0 by @mathias */\n\n  var stringFromCharCode = String.fromCharCode;\n  var floor = Math.floor;\n  function fromCodePoint() {\n    var MAX_SIZE = 0x4000;\n    var codeUnits = [];\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return '';\n    }\n    var result = '';\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (\n        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n        codePoint < 0 || // not a valid Unicode code point\n        codePoint > 0x10FFFF || // not a valid Unicode code point\n        floor(codePoint) != codePoint // not an integer\n      ) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        // BMP code point\n        codeUnits.push(codePoint);\n      } else {\n        // Astral code point; split in surrogate halves\n        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n      if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n        result += stringFromCharCode.apply(null, codeUnits);\n        codeUnits.length = 0;\n      }\n    }\n    return result;\n  }\n\n  function assertType(type, expected) {\n    if (expected.indexOf('|') == -1) {\n      if (type == expected) {\n        return;\n      }\n\n      throw Error('Invalid node type: ' + type);\n    }\n\n    expected = assertType.hasOwnProperty(expected)\n      ? assertType[expected]\n      : (assertType[expected] = RegExp('^(?:' + expected + ')$'));\n\n    if (expected.test(type)) {\n      return;\n    }\n\n    throw Error('Invalid node type: ' + type);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  function generate(node) {\n    var type = node.type;\n\n    if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {\n      return generate[type](node);\n    }\n\n    throw Error('Invalid node type: ' + type);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  function generateAlternative(node) {\n    assertType(node.type, 'alternative');\n\n    var terms = node.body,\n        length = terms ? terms.length : 0;\n\n    if (length == 1) {\n      return generateTerm(terms[0]);\n    } else {\n      var i = -1,\n          result = '';\n\n      while (++i < length) {\n        result += generateTerm(terms[i]);\n      }\n\n      return result;\n    }\n  }\n\n  function generateAnchor(node) {\n    assertType(node.type, 'anchor');\n\n    switch (node.kind) {\n      case 'start':\n        return '^';\n      case 'end':\n        return '$';\n      case 'boundary':\n        return '\\\\b';\n      case 'not-boundary':\n        return '\\\\B';\n      default:\n        throw Error('Invalid assertion');\n    }\n  }\n\n  function generateAtom(node) {\n    assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');\n\n    return generate(node);\n  }\n\n  function generateCharacterClass(node) {\n    assertType(node.type, 'characterClass');\n\n    var classRanges = node.body,\n        length = classRanges ? classRanges.length : 0;\n\n    var i = -1,\n        result = '[';\n\n    if (node.negative) {\n      result += '^';\n    }\n\n    while (++i < length) {\n      result += generateClassAtom(classRanges[i]);\n    }\n\n    result += ']';\n\n    return result;\n  }\n\n  function generateCharacterClassEscape(node) {\n    assertType(node.type, 'characterClassEscape');\n\n    return '\\\\' + node.value;\n  }\n\n  function generateCharacterClassRange(node) {\n    assertType(node.type, 'characterClassRange');\n\n    var min = node.min,\n        max = node.max;\n\n    if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {\n      throw Error('Invalid character class range');\n    }\n\n    return generateClassAtom(min) + '-' + generateClassAtom(max);\n  }\n\n  function generateClassAtom(node) {\n    assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');\n\n    return generate(node);\n  }\n\n  function generateDisjunction(node) {\n    assertType(node.type, 'disjunction');\n\n    var body = node.body,\n        length = body ? body.length : 0;\n\n    if (length == 0) {\n      throw Error('No body');\n    } else if (length == 1) {\n      return generate(body[0]);\n    } else {\n      var i = -1,\n          result = '';\n\n      while (++i < length) {\n        if (i != 0) {\n          result += '|';\n        }\n        result += generate(body[i]);\n      }\n\n      return result;\n    }\n  }\n\n  function generateDot(node) {\n    assertType(node.type, 'dot');\n\n    return '.';\n  }\n\n  function generateGroup(node) {\n    assertType(node.type, 'group');\n\n    var result = '(';\n\n    switch (node.behavior) {\n      case 'normal':\n        break;\n      case 'ignore':\n        result += '?:';\n        break;\n      case 'lookahead':\n        result += '?=';\n        break;\n      case 'negativeLookahead':\n        result += '?!';\n        break;\n      default:\n        throw Error('Invalid behaviour: ' + node.behaviour);\n    }\n\n    var body = node.body,\n        length = body ? body.length : 0;\n\n    if (length == 1) {\n      result += generate(body[0]);\n    } else {\n      var i = -1;\n\n      while (++i < length) {\n        result += generate(body[i]);\n      }\n    }\n\n    result += ')';\n\n    return result;\n  }\n\n  function generateQuantifier(node) {\n    assertType(node.type, 'quantifier');\n\n    var quantifier = '',\n        min = node.min,\n        max = node.max;\n\n    switch (max) {\n      case undefined:\n      case null:\n        switch (min) {\n          case 0:\n            quantifier = '*'\n            break;\n          case 1:\n            quantifier = '+';\n            break;\n          default:\n            quantifier = '{' + min + ',}';\n            break;\n        }\n        break;\n      default:\n        if (min == max) {\n          quantifier = '{' + min + '}';\n        }\n        else if (min == 0 && max == 1) {\n          quantifier = '?';\n        } else {\n          quantifier = '{' + min + ',' + max + '}';\n        }\n        break;\n    }\n\n    if (!node.greedy) {\n      quantifier += '?';\n    }\n\n    return generateAtom(node.body[0]) + quantifier;\n  }\n\n  function generateReference(node) {\n    assertType(node.type, 'reference');\n\n    return '\\\\' + node.matchIndex;\n  }\n\n  function generateTerm(node) {\n    assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');\n\n    return generate(node);\n  }\n\n  function generateValue(node) {\n    assertType(node.type, 'value');\n\n    var kind = node.kind,\n        codePoint = node.codePoint;\n\n    switch (kind) {\n      case 'controlLetter':\n        return '\\\\c' + fromCodePoint(codePoint + 64);\n      case 'hexadecimalEscape':\n        return '\\\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);\n      case 'identifier':\n        return '\\\\' + fromCodePoint(codePoint);\n      case 'null':\n        return '\\\\' + codePoint;\n      case 'octal':\n        return '\\\\' + codePoint.toString(8);\n      case 'singleEscape':\n        switch (codePoint) {\n          case 0x0008:\n            return '\\\\b';\n          case 0x009:\n            return '\\\\t';\n          case 0x00A:\n            return '\\\\n';\n          case 0x00B:\n            return '\\\\v';\n          case 0x00C:\n            return '\\\\f';\n          case 0x00D:\n            return '\\\\r';\n          default:\n            throw Error('Invalid codepoint: ' + codePoint);\n        }\n      case 'symbol':\n        return fromCodePoint(codePoint);\n      case 'unicodeEscape':\n        return '\\\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);\n      case 'unicodeCodePointEscape':\n        return '\\\\u{' + codePoint.toString(16).toUpperCase() + '}';\n      default:\n        throw Error('Unsupported node kind: ' + kind);\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  generate.alternative = generateAlternative;\n  generate.anchor = generateAnchor;\n  generate.characterClass = generateCharacterClass;\n  generate.characterClassEscape = generateCharacterClassEscape;\n  generate.characterClassRange = generateCharacterClassRange;\n  generate.disjunction = generateDisjunction;\n  generate.dot = generateDot;\n  generate.group = generateGroup;\n  generate.quantifier = generateQuantifier;\n  generate.reference = generateReference;\n  generate.value = generateValue;\n\n  /*--------------------------------------------------------------------------*/\n\n  // export regjsgen\n  // some AMD build optimizers, like r.js, check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // define as an anonymous module so, through path mapping, it can be aliased\n    define(function() {\n      return {\n        'generate': generate\n      };\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Narwhal, Node.js, Rhino -require, or RingoJS\n    freeExports.generate = generate;\n  }\n  // in a browser or Rhino\n  else {\n    root.regjsgen = {\n      'generate': generate\n    };\n  }\n}.call(this));\n"]}